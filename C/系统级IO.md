内核用三个相关的数据结构来表示打开的文件：
* 描述符表。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。
* 文件表。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数（即当前指向该表项的描述符表项数），  
以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。
* v-node表。同文件表一样，所有的进程共享这张v-node表，每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。

#### 示例1
描述符1和4通过不同的打开文件表表项来引用两个不同的文件，这是一种典型的情况，没有共享文件，并且每个描述符对应一个不同的文件。
![打开文件的内核数据结构，没有共享](../Android/引用图片/打开文件的内核数据结构（未共享）.jpg)

#### 示例2
多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，以同一个文件名调用open函数两次，就会发生这种情况。关键思想就是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。
![打开文件的内核数据结构，没有共享](../Android/引用图片/打开文件的内核数据结构（共享）.jpg)

父子进程共享文件，子进程有一个父进程描述符的副本，父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个重要的结果就是，在内核删除相应文件表表项之前，父子进程都必须关闭了它们的描述符。

## 标准I/O都是缓存I/O（非标准I/O：内存映射则不需缓存在内核缓冲区）
标准I/O都是缓存I/O，操作系统会将I/O的数据缓存在文件系统对应的内存页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
由此可见缓存I/O存在的缺点：读写文件需要在应用程序和内核之间进行多次数据拷贝操作

以read为例，当一个read操作会经历两个阶段：
1. 等待数据就绪 (Waiting for the data to be ready)
2. 将数据从内核拷贝到应用进程中 (Copying the data from the kernel to the process)
