变量分为内部变量和外部变量，外部变量在函数外定义，因此可以在多个函数中使用。而函数本身就是“外部的”，所以函数本身就对于其他源文件可见，但最好自己源文件也声明一下（不定义），因为低版本不声明可能是非法的）。

本文件中，外部变量和函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。
例如：
```
main() {...}

int sp = 0;
double val[MAXVAL];

void push(double f) {...}
double pop(void) {...}
```
在push和pop这两个函数中，不需要进行任何声明就可以通过名字访问变量sp和val，但是这两个变量不能用在main函数中，push和pop也不能用在main函数中。

如果要外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字`extern`。

将外部变量的*声明*和*定义*的概念分开很重要。变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此以外还将引起存储器的分配。

如果将下列语句放在所有函数的外部:
```
int sp;
double val[MAXVAL];
```
那么这两条语句将*定义*外部变量sp和val，并为之分配存储单元，同时也作为该源文件中其余部分的声明。
而下面的两条语句：
```
extern int sp;
extern double val[];
```
&emsp;&emsp;为源文件的其余部分声明了一个int类型的外部变量sp以及一个double数组类型的外部变量val（该数组的长度在其他地方确定），但这两个变量并没有建立变量或为它们分配存储单元。

&emsp;&emsp;在一个源程序的所有源文件中，一个外部变量只能在某个文件中*定义*一次，而其他文件可以通过`extern`声明来访问它（定义外部变量的源文件也可以包含对该外部变量的`extern`声明）。外部变量的定义中必须指定数组的长度，但`extern`声明则不一定要指定数组的长度。

外部变量的初始化只能出现在其定义中。
```
//文件1
extern int sp;
extern double val[];

void push(double f) {...}
double pop(void) {...}
```

```
//文件2
int sp = 0;
double val[MAXVAL];
```

## 存储类别
从硬件来看，被存储的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象（Object），对象可以存储一个或多个值。一个对象可能并未存储实际的值，但是它在存储适当的值时一定具有相应的大小（和面向对象编程中的对象是两个概念）。

从软件来看，程序需要一种方法访问对象。这可以通过声明变量来完成：
```
int entity = 3;
```
该声明创建了一个名为`entity`的*标识符*（identifier）。标识符是一个名称，在这种情况下，标识符可以用来指定特定对象的内容。在该例中，标识符`entity`即是软件（C程序）指定硬件内存中的对象的方式。该声明还提供了存储在对象中的值。

可以用**存储期**描述对象，所谓存储期是指对象在内存中保留了多长时间。**标识符**用于访问对象，可以用**作用域**和**链接**描述标识符，表明程序的哪些部分可以使用它。标识符可在多文件、单文件、函数内甚至仅限代码块中使用。对象可存在于程序的执行期，也可仅存于所在函数的执行期。对于并发编程，对象可以在指定线程的执行期存在。可以通过函数调用的方式显示分配和释放内存。

## 作用域
*作用域*描述程序中可访问标识符的区域。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。

> **翻译单元和文件**  
一个源文件可能包含多个头文件，头文件也可能包含其他头文件，所以一共是多个单独的物理文件。但是C预处理实际是用包含的头文件内容替换#include指令。所以，对于编译器来说，源文件和其包含的所有头文件是一个包含信息的单独文件，这个文件被称为**翻译单元（translation unit）**。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成，每个翻译单元均对应一个源文件和它所包含的文件。

所以头文件中的变量或函数等，源文件中都可以访问。

## 链接
C变量有三种链接属性：外部链接、内部链接、无链接。  
具有块作用域、函数作用域、函数原型作用域的变量都是**无链接变量**，这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是**外部链接**或**内部链接**。  
**外部链接变量**可以在多文件程序中使用，**内部链接变量**只能在一个*翻译单元*中使用。

> C标准用“内部链接的文件作用域”描述仅限一个*翻译单元*（即一个源文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。  
前者可简称“文件作用域”，后者可简称“全局作用域”或“程序作用域”。

文件作用域变量是内部链接还是外部链接的关键在于外部定义时是否使用了存储类别说明符`static`

```
int giants = 5;            //文件作用域，外部链接
static int dodgers = 3;    //文件作用域，内部链接
int main(){
    ...
}
```
该文件和同一程序的其他文件都可以使用`giants`变量，而`dodgers`变量属于文件私有。

## 存储期
作用域和链接描述了标识符的可见性。存储期描述了**通过这些标识符访问的对象的生存期**。C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

* 静态存储期：在程序的执行期间一直存在。*文件作用域变量*具有静态存储期。注意：对于*文件作用域变量*，关键字`static`表明其链接属性，而非存储期。无论时内部链接还是外部链接，所有的*文件作用域变量*都具有静态存储期。
* 线程存储期：用于并发程序设计，程序执行可被氛围多个线程。线程存储期的对象，从被声明时到线程结束一直存在。以关键字`_Thread_local`声明一个对象时，每个线程都获得该变量的私有备份。
* 自动存储期：块作用域变量具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存，退出这个块时，释放刚才为变量分配的内存。

变长数组稍有不同，它们的存储期从声明到块的末尾，而不是从块的开始处到块的末尾。

块作用域变量一般是自动存储期，但是也能具有静态存储期。把变量声明在块中，并且在声明前加上关键字`static`：
```
void more(int number){
    int index;
    static int ct = 0;
    ...
    return 0;
}
```
这里的`ct`变量存储在静态内存中，它从程序被载入到程序结束期间都存在。然是它的作用域仅在`more()`函数块中。（但是通过指针形参或返回值使其他函数间接访问此变量）。

|存储类别|存储期|作用域|链接|声明方式|
|---|---|---|---|---|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内，使用关键字register|
|静态外部链接|静态|文件|外部|所有函数外|
|静态内部链接|静态|文件|内部|所有函数外，使用关键字static|
|静态无链接|静态|块|无|块内，使用关键字static|

> 静态变量（静态存储期变量），听起来像是一个不可变的变量，但实际上，静态的意思是该变量在内存中原地不动，并不是它的值不变。C语言中的静态变量并不是一定要加static关键字，文件作用域的外部链接变量没有static也是静态变量。要以存储期为依据。

## 自动变量
一般叫局部变量，默认情况，声明在块或者函数中的变量就是自动变量，也可以在变量声明前加上`auto`来明确说明是自动变量。
```
void fun(){
    auto int a;   //明确表示是自动变量，也可以不加auto
}
```

## 外部链接的静态变量

&emsp;&emsp;外部链接的静态变量可称为外部变量（external variable），其具有文件作用域、外部链接和静态存储期。把变量的定义性声明（defining declaration）放在所有函数的外面便创建了外部变量。  
&emsp;&emsp;当然，为了表示某函数使用了外部变量，可以在函数中用关键字`extern`再次声明（一般直接用外部变量就行）。而如果一个源文件使用的外部变量定义在另一个源文件中，则必须使用`extern`在该文件中声明该变量。
```
int Errupt;               // 外部定义的变量
double Up[100];           // 外部定义的数组
extern char Coal;         // 如果Coal定义在另一个源文件，则必须这样声明才能访问

void next(void);
int main(void){
    extern int Errupt;    // 可选的声明
    extern double Up[];   // 可选的声明
}

void next(void){
    ...
}
```
&emsp;&emsp;在main()中声明Up数组时（这时可选的声明）不用指明数组大小，因为第一次声明已经提供。main()中的两个`extern`声明完全可以省略（连同声明，不是只省略extern）。如果只省略`extern`关键字，则创建了一个自动变量。  
&emsp;&emsp;比如在main()中省略下面声明中的extern：
```
extern int Errupt;
```
使成为：
```
int Errupt;
```
这使得编译器在main()中创建了一个名为`Errupt`的自动变量。它使一个独立的局部变量，与原来的外部变量`Errupt`不同。该局部变量仅main()可见，但是外部变量`Errupt`对于该文件的其他函数（如next函数）仍可见。简而言之，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用`auto`关键字明确表达这种意图（也是可选的）。

#### 初始化外部变量
外部变量和自动变量类似，也可以被显式初始化。和自动变量不同的是，如果没有初始化外部变量，它们会被自动初始化为0.这一原则也适用于外部定义的数组元素。

#### 定义和声明
定义变量和声明变量的区别，考虑下面例子：
```
int tern = 1;         // tern被定义
main(){
    extern int tern;  // 使用在别处定义的tern
}
```
这里，`tern`被声明了两次。第一次声明为变量预留了存储空间，该声明构成了变量的定义。第二次声明只告诉编译器使用之前已创建的`tern`变量，所以这不是定义。第一次声明被称为**定义式声明**，第二次声明被称为**引用式声明**。关键字`extern`表明该声明不是定义，指示编译器去别处查询其定义。

假设这样写：
```
extern int tern;
int main(){
    ...
}
```
编译器会假设`tern`的实际定义在该程序的别处，也许在别的文件中。该声明不会引起分配存储空间，因此不能使用关键字`extern`创建外部定义，只能用于引用现有的外部定义。

## 多文件
&emsp;&emsp;只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。  
&emsp;&emsp;复杂的C程序通常由多个单独的源代码文件组成。有时，有些文件可能要共享一个外部变量，C语言通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用`extern`关键字。而且只有定义式声明才可以初始化变量。

## 存储类别和函数
函数也由存储类别，可以式外部函数（默认）或静态函数。C99新增了第3种类别--内联函数。外部函数可以被其他文件中的函数访问，静态函数只能用于其定义所在的文件。
double gamma(double);              // 默认为外部函数
static double beta(int, int);      // 静态函数
extern double delta(double, int);  // 其他文件的函数

一般用`extern`声明定义在其他文件的函数，实际也可以不加`extern`。甚至使用其他文件的函数前不用声明（C99及以前不行）。