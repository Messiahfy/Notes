## Future
和JS类似的单线程异步，虽然简化和减少了线程并发安全问题，但实际上还是存在类似的异步操作顺序不可控问题，表现和线程安全问题类似。

执行到await时，控制权返回事件循环。

例如以下问题：
```dart
class CounterService {
  int _counter = 0;
  
  Future<void> incrementAsync() async {
    // 读取当前值
    int current = _counter;
    
    // 模拟一些异步操作（如网络请求、数据库操作等）
    await Future.delayed(Duration(milliseconds: 100));
    
    // 基于读取的值进行更新
    _counter = current + 1;
  }
}

// 可能出现的问题：
// 如果同时调用两次 incrementAsync()
// 两次调用可能都会读取到相同的 _counter 值
// 然后各自加1，最终结果只增加了1而不是2



class UserService {
  Map<String, User> _users = {};
  
  Future<User> fetchAndUpdateUser(String userId) async {
    // 网络请求获取用户数据
    User user = await api.fetchUser(userId);
    
    // 在获取数据和更新之间，可能有其他操作修改了用户数据
    await Future.delayed(Duration(milliseconds: 50)); // 模拟处理时间
    
    // 这里可能覆盖了其他地方的更新
    _users[userId] = user;
    return user;
  }
}
```

比如一些解决方式：
* 状态隔离
* 判断状态、条件，要同步判断，不能调用异步函数中判断，确保拿到的是最新状态
* 异步之后，double check
* 自行添加状态位（比如过程中禁用按钮）
* 实现队列
* 使用 Cancellation Token
* 利用状态管理库如Provider的特性
* synchronized库：https://pub.dev/packages/synchronized

### SynchronousFuture
```dart
Future<String> testFakeAsync() async{
  print("testFakeAsync  ${StackTrace.current}");
  return "123";
}

void test1() async {
    print("test1 start");
    var result = await testFakeAsync();
    print("test1 end  result: $result");
}
// 打印结果：
test1 start
hhhhh testFakeAsync  #0      _MyHomePageState.testFakeAsync (package:all_platform/main.dart:121:42)
#1      _MyHomePageState.test1 (package:all_platform/main.dart:107:24)
.... 省略调用栈的其他函数
test1 end  result: 123


void test2() async {
    print("test2 start");
    testFakeAsync().then((value) {
      print("test2 result: $value");
    });
    print("test2 end");
}

// 运行结果：
test2 start
hhhhh testFakeAsync  #0      _MyHomePageState.testFakeAsync (package:all_platform/main.dart:123:42)
#1      _MyHomePageState.test2 (package:all_platform/main.dart:107:5)
.... 省略调用栈的其他函数
test2 end
test2 result: 123
```
`testFakeAsync`是一个异步函数，但它内部实际并没有真实异步，从它的调用栈打印可以看到，无论使用`await`关键字还是`then`，它都是同步执行的。区别在于使用`then`的情况下，结果回调是异步的，因为所有 `then()` 回调都会进入微任务队列，这是 Dart 的硬性规定

**而`SynchronousFuture`是同步的，它的then回调也是立即执行的**：
```dart
// ⚠️注意，这里没有加 async 关键字，因为加了 async 则会自动再包装一层 Future，导致 SynchronousFuture 失效
Future<String> testFakeAsync() {
  print("testFakeAsync  ${StackTrace.current}");
  return SynchronousFuture("123");
}

void test3() async {
    print("test3 start");
    testFakeAsync().then((value) {
      print("test3 result: $value");
    });
    print("test3 end");
}
// 输出结果：
test3 start
hhhhh testFakeAsync  #0 ......省略调用栈
test3 result: 123
test3 end
```

## Stream
StreamController的broadcast对应的stream不会缓存数据，也就是说开始listen后，发的数据才会被收到，之前发的数据不会收到。而普通StreamController情况对应的stream会缓存。

## Completer
Completer是Dart dart:async库中的一个类，用于创建和控制Future。它允许开发者手动完成一个Future，使得Future的完成时机可以由代码逻辑自由控制，而不是由某个异步操作自动决定。

可以用于将回调API转换为Future API：
```dart
// 传统的回调方式
void fetchDataWithCallback(Function(String) onSuccess, Function(Exception) onError) {
  // 模拟异步操作
  Future.delayed(Duration(seconds: 2), () {
    onSuccess('数据加载成功');
  }).catchError((error) {
    onError(error);
  });
}

// 使用Completer转换为Future API
Future<String> fetchDataWithFuture() {
  final completer = Completer<String>();
  
  fetchDataWithCallback(
    (data) => completer.complete(data),
    (error) => completer.completeError(error),
  );
  
  return completer.future;
}
```

## 取消
async包提供了`CancelableOperation`，有取消回调，**但并没有提供异步函数内感知取消的功能**，只能手动管理（比如加标志位double check、或者通过Completer结合异常中断流程）。需要额外封装一下。

一个`CancelableOperation`结合标志位的例子：
```dart
import 'package:async/async.dart';

// 自定义取消令牌类
class CancellationToken {
  bool _isCancelled = false;
  
  bool get isCancelled => _isCancelled;
  
  void cancel() {
    _isCancelled = true;
  }
}

Future<void> main() async {
  // 创建取消令牌实例
  final token = CancellationToken();
  
  final cancelableOp = CancelableOperation.fromFuture(
    _longRunningTask(token), // 传递令牌实例
    onCancel: () {
      print('开始取消流程...');
      token.cancel(); // 设置取消状态
      return Future.value('取消完成');
    },
  );

  Future.delayed(Duration(seconds: 2), () {
    cancelableOp.cancel();
  });

  try {
    final result = await cancelableOp.value;
    print('结果: $result');
  } on CancellationException {
    print('操作被取消');
  }
}

// 任务函数接收令牌实例
Future<String> _longRunningTask(CancellationToken token) async {
  for (var i = 0; i < 10; i++) {
    // 检查令牌的取消状态
    if (token.isCancelled) {
      print('收到取消信号，准备退出');
      return '操作已取消';
    }
    
    print('处理第 $i 步...');
    await Future.delayed(Duration(seconds: 1));
  }
  return '完成';
}
```

> CancelableOperation 不是 “异步执行流中断器”，而是 “状态标记器”

`CancelableCompleter`：`CancelableOperation`就基于它实现

`dio`包自带取消支持：
```dart
import 'package:dio/dio.dart';

Future<void> fetchWithDio() async {
  final dio = Dio();
  final cancelToken = CancelToken();

  // 可取消的请求
  final response = await dio.get(
    'https://api.example.com/data',
    cancelToken: cancelToken,
  );

  // 在任何地方调用 cancel() 来取消
  // cancelToken.cancel('用户取消');
  
  return response.data;
}
```

> 三方库 `cancellation_token` 也可以考虑

> 异步任务完，建议检测 `mounted`

https://pub.dev/packages/scopely 这个库包装了 Future和Stream，提供了cancel()方法，可以取消异步任务。但只能做到取消后，正在执行的异步函数之后的异步函数不会执行（依靠异常机制），但不能让正在执行的异步函数提前结束（异步函数内不能感知取消）。**可能需要结合CancellationToken之类的思想**
```dart
class CancellationToken {
  bool _isCancelled = false;
  bool get isCancelled => _isCancelled;
  void cancel() => _isCancelled = true;
}

Future<int> fetchInt(CancellationToken token) async {
  for (int i = 0; i < 10; i++) {
    await Future.delayed(Duration(milliseconds: 500));
    if (token.isCancelled) throw Exception('Cancelled');
  }
  return 5;
}
```


下面是一个完整的 Dart 方案，用于实现类似 Kotlin 协程取消感知的异步编程体验，**支持在异步任务内部感知取消，并可与 AsyncScope 结合统一管理**。  
方案包含：

1. CancellationToken 及其集成 AsyncScope 的实现
2. 扩展方法 inScopeWithCancellation
3. 使用示例与说明

---

```dart
import 'dart:async';

/// 1. CancellationToken 定义
class CancellationToken {
  bool _isCancelled = false;
  final List<VoidCallback> _listeners = [];

  bool get isCancelled => _isCancelled;

  void cancel() {
    if (!_isCancelled) {
      _isCancelled = true;
      for (final listener in _listeners) {
        try {
          listener();
        } catch (_) {}
      }
      _listeners.clear();
    }
  }

  /// 注册取消时回调
  void addListener(VoidCallback callback) {
    if (_isCancelled) {
      callback();
    } else {
      _listeners.add(callback);
    }
  }
}

typedef VoidCallback = void Function();

/// 2. AsyncScope 支持 CancellationToken
class AsyncScope {
  final Set<CancellationToken> _tokens = {};
  bool _isCancelled = false;

  bool get isCancelled => _isCancelled;

  /// 生成一个自动跟随 Scope 生命周期的 token
  CancellationToken createToken() {
    if (_isCancelled) throw StateError("Scope already cancelled");
    final token = CancellationToken();
    _tokens.add(token);
    token.addListener(() => _tokens.remove(token));
    return token;
  }

  /// 取消所有绑定的 token
  void cancelAll() {
    if (_isCancelled) return;
    _isCancelled = true;
    for (final token in _tokens.toList()) {
      token.cancel();
    }
    _tokens.clear();
  }
}

/// 3. 扩展方法，便于集成 token
extension FutureWithScope<T> on Future<T> Function(CancellationToken token) {
  Future<T> inScope(AsyncScope scope) {
    final token = scope.createToken();
    return this(token);
  }
}

/// 4. 异步任务示例：内部感知取消
Future<int> fetchInt(CancellationToken token) async {
  for (int i = 0; i < 10; i++) {
    await Future.delayed(Duration(milliseconds: 500));
    if (token.isCancelled) throw Exception('Cancelled!');
    print('Tick $i');
  }
  return 5;
}

/// 5. 使用示例
void main() async {
  final scope = AsyncScope();

  // 启动异步任务
  final future = fetchInt.inScope(scope);

  // 2 秒后取消
  Future.delayed(Duration(seconds: 2), () {
    print('Cancelling scope...');
    scope.cancelAll();
  });

  // 处理结果/异常
  try {
    final result = await future;
    print('Result: $result');
  } catch (e) {
    print('Task was cancelled: $e');
  }
}
```


rxdart：只会让下游不再收到事件，但上游（比如异步任务、网络请求、Timer 等）是否能被真正中断，取决于你的代码实现，上游的 Stream 可能依然在产生事件，只是没人再监听了。


## Zone
`Zone` 是 Dart 语言中用来管理“异步执行环境”的机制，在 Flutter 开发中几乎是全局异常捕获最核心、最常用的方式。

可以把 Zone 理解成：
* 一个异步代码的“沙盒” 或 “上下文环境”
* 它能跨异步调用保持稳定（Future、Stream、Timer、microtask 等等都在同一个 Zone 里运行）
* 它可以拦截、修改、观察这个沙盒里发生的异步行为（一般用来捕获整个应用中所有未被 try-catch 住的异步异常）

一个 Isolate 内部可以有多个 Zone（树状结构），每个 Isolate 内部维护一个线程局部变量（thread-local storage） → currentZone，所有代码执行时，都会读取这个指针来决定“我现在在哪个 Zone 里”，刚启动的 Isolate，它的 currentZone 指向 root zone（根区域）。

> 但我们没有自己创建 Zone 的话，默认应该就只有 root Zone

每个 Zone 都有一个 parent 指针，指向父 Zone，几乎所有异步操作（Future、Stream、Timer、microtask、await 等，本质都是回调）在注册回调时，都会做两件事：
1. 调用 Zone.current.registerCallback(fn) 或 Zone.current.bindCallback(fn)
→ 把原始函数 fn 包装成一个绑定了当前 Zone 的函数
2. 这个包装后的函数被真正注册到事件队列 / 定时器 / Completer 里