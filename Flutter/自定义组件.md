## 概述
平时常用的`StatelessWidget`和`StatefulWidget`只是用来组合或者包装其他`Widget`的容器，实际布局和绘制是由`RenderObjectWidget`相关的`RenderObject`来完成。

在Flutter应用启动流程的分析中，了解到了关于布局和绘制的大致流程，下面进一步具体分析，以此来学习自定义布局和绘制的方式和注意点。

## 布局绘制流程
### 布局
下面是简化后，保留关键点的`layout`函数：
```dart
// RenderObject

void layout(Constraints constraints, { bool parentUsesSize = false }){
  ...
  RenderObject? relayoutBoundary;
  if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {
    relayoutBoundary = this;
  } else {
    relayoutBoundary = (parent as RenderObject)._relayoutBoundary;
  }
  _constraints = constraints;
  _relayoutBoundary = relayoutBoundary;
  if (sizedByParent) {
    ...
    performResize();
    ...
  }
  performLayout();
  ...
}
```
父`RenderObject`会调用子`RenderObject`的`layout`函数，从而完成全部的布局。

参数说明：
* `constraints`参数：父节点传给子节点的尺寸约束，一般是`BoxConstraints`，包含最大和最小的宽度高度，如果最大等于最小，就表示确切的尺寸。
* `parentUsesSize`参数：如果是true（还要考虑`sizedByParent`等变量），将设置`_relayoutBoundary`为父节点的`_relayoutBoundary`，在`markNeedsLayout()`方法中会判断`_relayoutBoundary`不是自身，就会向上调用父节点的`markNeedsLayout()`方法。也就是说，`parentUsesSize`将使子节点自身布局变化时通知父节点。

`RenderObject`的属性和方法说明：
* `sizedByParent`属性默认为false，如果重写为true，表示父节点传来的`constraints`是决定当前节点尺寸的唯一参考，那么`size`应该在`performResize()`中通过`constraints`去设置，而**不用**在`performLayout()`中再参考子节点的`size`。当然，这只是一种约定，但建议遵守。
* `performResize()`：如果重写`sizedByParent`属性为true，layout会调用此方法，作用如上所述。
* `performLayout()`：如果有子节点的话，一是调用`child.layout`来对子节点布局（子节点确定自身尺寸，相当于Android的测量），二是设置`child.parentData.offset`来对子节点**定位**；无论有没有子节点，都需要设置自身尺寸，但如果设置了`sizedByParent`，则不需要。并且，无论有没有子节点，都要设置自己的size。

> 在Flutter应用启动流程笔记中，写到我们传的根Widget对应的RenderObject会被强制铺满屏幕，就是因为`RenderView`的`performLayout`方法中，传给child的约束就是屏幕的大小

#### BoxConstraints 和 performLayout
`BoxConstraints`的核心字段就是这4个：
```dart
class BoxConstraints extends Constraints {
  const BoxConstraints({
    this.minWidth = 0.0,
    this.maxWidth = double.infinity,
    this.minHeight = 0.0,
    this.maxHeight = double.infinity,
  });

  // ...
}
```

自定义布局时，主要是重写 `performLayout`，以较简单的`RenderPadding`为例
```dart
  @override
  void performLayout() {
    final BoxConstraints constraints = this.constraints;
    _resolve(); // 计算 _resolvedPadding
    if (child == null) {
      size = constraints.constrain(Size(
        _resolvedPadding!.left + _resolvedPadding!.right,
        _resolvedPadding!.top + _resolvedPadding!.bottom,
      ));
      return;
    }
    final BoxConstraints innerConstraints = constraints.deflate(_resolvedPadding!);
    // 调用 child 的 layout
    child!.layout(innerConstraints, parentUsesSize: true);
    final BoxParentData childParentData = child!.parentData! as BoxParentData;
    // 设置 offset
    childParentData.offset = Offset(_resolvedPadding!.left, _resolvedPadding!.top);
    size = constraints.constrain(Size(
      _resolvedPadding!.left + child!.size.width + _resolvedPadding!.right,
      _resolvedPadding!.top + child!.size.height + _resolvedPadding!.bottom,
    ));
  }
```
核心流程就是：
1. 创建合适的 `BoxConstraints`，调用 `child` 的 `layout` 方法，`child` 会计算好自己的 `size`
2. 给 `child` 的 `parentData` 设置 `offset`，在调用 `child` 的 `paint` 方法时会使用
3. 结合 `child` 的 `size` 和其他配置信息，设置自己的 `size`

> size 会用于事件分发 hitTest，以及在 paint 时使用

> 可以查看官方文档对约束的描述：https://docs.flutter.dev/ui/layout/constraints，**核心就是父级向子级传递约束，子级向父级返回size**

### 绘制
```
//RenderObject#paint

void paint(PaintingContext context, Offset offset) {
  //...
}
```
绘制部分较简单，核心就是使用`PaintingContext`中的`canvas`来绘制。如果有子节点，一般还需要调用`context.paintChild(child, child.parentData.offset + offset)`来执行子节点的绘制，`paintChild`方法传的`offset`就是布局时给子节点设置的相对于父节点的偏移加上父节点的偏移。

可以参考 Container 中使用的 RenderDecoratedBox 的 paint 方法。

> Flutter 中没有像 Android 那样默认会 clipRect 让子级不能绘制超出父级的范围，除非设置 `clipChildren` 为false，但 Flutter 没有这个限制，如果实现的 paint 没有合理使用 size 和 offset ，其实是可以随意绘制到当前范围之外的。

> 可以参考文章：玩转自定义绘制 https://juejin.cn/post/7446634545867046922