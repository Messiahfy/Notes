.NET是一个平台，而.NET平台有一个实现标准，叫做`.Net Standard`，`.Net Framework`、`.Net Core`、`Mono`都实现了这个标准；而这三个实现都有自己的引擎，这个引擎就是CLR，粗暴点可以理解为CLR来执行你编译好的东西；C#只是一个编程语言，而同样支持.NET的语言还有F#、VB.NET。

.NET框架是一个独立发布的软件包，其包含了CLR、基础类库以及相关的语言编译器、SDK等工具。

CLR：Common Language Runtime 是一个执行引擎，用于运行程序，提供类型系统、垃圾回收、JIT等功能；目前有3个主要实现，分别为coreclr用于.Net Core、desktop clr用于.Net Framework（有了coreclr之后才获得的一个相对”名称）、Mono（没人给其中的runtime部分单独取名）

# 基本语法
## 变量声明
```c#
//显式类型声明
int age = 25;
List<string> names = new List<string>();

// 使用var隐式类型推断（C# 3.0+）
var count = 10; // 编译器推断为int
var list = new List<int>(); // 推断为List<int>

// 使用new()简化（C# 9.0+）
List<string> list = new(); // 省略类型

// dynamic动态类型（C# 4.0+）
dynamic obj = GetSomeObject();
obj.DoSomething(); // 运行时解析
```

可空值类型
```c#
int? n1 = null;
```

可空引用类型
```c#
string? name = null;
```

数组，是引用类型
```c#
int[] myArray = new int[4];
int[] myArray1 = new int[4] {4, 7, 11, 2};
int[] myArray2 = new int[] {4, 7, 11, 2};
int[] myArray3 = {4, 7, 11, 2};
```

数组支持切片，切片会从原数组中复制指定区间的元素，生成独立的新数组，新数组和原数组是两块完全独立的内存
```c#
int[] arr = { 0, 1, 2, 3, 4 };
int[] slice = arr[1..3]; // 拷贝原数组[1,2] → 新数组[1,2]
slice[0] = 99; // 修改新数组
Console.WriteLine(arr[1]); // 输出：1 【原数组无变化】
Console.WriteLine(slice[0]);//输出：99
```

数组Span，原数组的视图，修改Span就会直接修改原数组。
```c#
int[] arr = { 0, 1, 2, 3, 4 };
Span<int> span = arr.AsSpan(1,2); // 零拷贝映射[1,2]
span[0] = 99; // 修改视图 → 直接改原数组
Console.WriteLine(arr[1]); // 输出：99 【原数组被修改】
Console.WriteLine(span[0]);//输出：99
```

`ArrayPool<T>`数组池的设计初衷是解决频繁创建 / 销毁数组导致的内存碎片、GC 压力大的问题。使用核心就是**租借 → 使用 → 归还**
```c#
// 1. 【租借数组】从全局池里租一个 长度≥所需长度 的数组
T[] buffer = ArrayPool<T>.Shared.Rent(需要的最小长度);

try
{
    // 2. 【使用数组】核心：用 Span<T> 切片使用「实际需要的长度」，忽略多余长度
    Span<T> span = buffer.AsSpan(0, 需要的最小长度);
    
    // 这里写你的业务逻辑：读取数据、切片、校验、处理...
    // ✅ 所有操作都基于Span完成，零拷贝、高性能
}
finally
{
    // 3. 【归还数组】必须在finally中归还！确保无论是否报错，数组都会归还到池里
    // ✅ 第二个参数 true：清空数组内容（安全，避免数据泄露），建议都传true
    ArrayPool<T>.Shared.Return(buffer, clearArray: true);
}
```

## 字符串
```c#
string s = "The quick brown fox jumped over the lazy dogs down " +"1234567890 times";
string the = s[..3];
string quick = s[4..9];
string times = s[^5..^0];
```

在C#中，is null 和 == null 都可以用于判空，但 is null 不受运算符重载影响

## 模式匹配
```c#
if (o is Book b){
    b.Title = "C# 8.0 in a Nutshell";
}
```
switch 语句也类似，可以使用模式匹配
```c#
switch (o) {
    case Book b:
        b.Title = "C# 8.0 in a Nutshell";
        break;
    case int i when i > 0:
        Console.WriteLine("Positive integer");
        break;
}
```

## using
using 除了普通的导入功能，还可以用于别名：
```c#
using TimersTimer = System.Timers.Timer;
```

## 预处理
```c#
#define
#undef

#if, #elif, #else, and #endif

#warning  #error

#region and #endregion

#nullable
```

## 元组
```c#
var t1 = (Number: 1, String: "a"); // 栈分配
var t2 = t1;
t2.Number = 2;
t2.String = "b"; // 不会影响t1
```

## 索引器
C#的类支持重写索引器，支持像数组一样的索引访问

# 方法
方法支持箭头符号 `=>` 用于简化lambda表达式
```c#
Func<int, int> square = x => x * x;
int result = square(5); // 25
```

支持可选参数
```c#
public void MoveAndResize(int x, int y, int width, int height)

r.MoveAndResize(x: 30, y: 40, width: 20, height: 40);
```

可选参数
```c#
public void TestMethod(int notOptionalNumber, int optionalNumber = 42)
{
    Console.WriteLine(optionalNumber + notOptionalNumber);
}

TestMethod(11);
TestMethod(11, 42);
```


## record类型
`record` 记录是支持值语义的引用类型。这种类型允许减少您需要编写的代码，因为编译器会自动实现按值比较记录并提供更多功能，比如不可变

## 结构体
结构体是值类型，栈分配或内联存储，传值时会复制整个值，适用于小型、不可变或短期使用的数据。
```c#
public struct Point
{
    public int X;  // 字段默认私有
    public int Y;
    
    // 构造函数必须初始化所有字段
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}
```

## 枚举
```c#
public enum Color
{
    Red,
    Green,
    Blue
}

public enum Color : short
{
    Red = 1,
    Green = 2,
    Blue = 3
}


[Flags]
public enum DaysOfWeek
{
    Monday = 0x1,
    Tuesday = 0x2,
    Wednesday = 0x4,
    Thursday = 0x8,
    Friday = 0x10,
    Saturday = 0x20,
    Sunday = 0x40
}

[Flags]
public enum DaysOfWeek
{
    Monday = 0x1,
    Tuesday = 0x2,
    Wednesday = 0x4,
    Thursday = 0x8,
    Friday = 0x10,
    Saturday = 0x20,
    Sunday = 0x40,
    Weekend = Saturday | Sunday,
    Workday = 0x1f,
    AllWeek = Workday | Weekend
}
```

## 引用
使用`ref` 值类型强制传递引用
```c#
int a = 1;
ChangeAValueType(ref a);
Console.WriteLine($"the value of a changed to {a}");
void ChangeAValueType(ref int x)
{
  x = 2;
}
```

`in` 关键字用于将参数传递给方法，而不允许方法修改参数的值。这在需要确保参数不被修改的情况下非常有用，例如在只读操作中。
如果要避免在将值类型传递给方法时复制值类型的开销，但又不想更改方法中的值，则可以使用修饰符
```c#
void PrintValue(in int x)
{
    Console.WriteLine(x);
}
```

`ref return` 为避免在方法返回时复制值，您可以使用关键字声明返回类型并使用
```c#
ref SomeValue Max(ref SomeValue x, ref SomeValue y)
{
    int sumx = x.Value1 + x.Value2 + x.Value3 + x.Value4;
    int sumy = y.Value1 + y.Value2 + y.Value3 + y.Value4;
    if (sumx > sumy)
    {
      return ref x;
    }
    else
    {
        return ref y;
    }
}
```

`out` 关键字用于将参数传递给方法，而允许方法修改参数的值。这在需要确保参数被修改的情况下非常有用，例如在写入操作中。
```c#

```


# 类
`readonly`属性是只能在构造函数中赋值的属性。
```c#
public class Person
{
    // readonly属性 - 只能在构造函数中初始化
    public readonly string Id { get; }
    
    // 传统readonly字段
    private readonly string _internalId;
    
    // 普通可写属性
    public string Name { get; set; }
    
    public Person(string id, string name)
    {
        Id = id;          // ✅ 构造函数中可以赋值
        _internalId = id;
        Name = name;
    }
    
    public void ChangeData()
    {
        // Id = "new-id";     // ❌ 编译错误：不能在方法中修改
        Name = "New Name";    // ✅ 普通属性可以修改
    }
}
```



`Init-Only Set Accessors`：C# 9.0引入的特性，用 init 关键字代替 set，允许属性只在对象构造期间（包括对象初始化器）被赋值。
```c#
public class Book
{
  public Book(string title)
  {
    Title = title;
  }

  public string Title { get; init; }
  public string? Publisher { get; init; }
}

Book theBook = new("Professional C#")
{
  Publisher = "Wrox Press"
};
```

`partial`（分部类型）是C#中允许将一个类、结构体或接口的定义拆分到多个文件中的特性。


* `virtual` 方法：可以被重写，有默认实现
```c#
base.xxx(); // 调用基类方法的方式，base相当于Java的super
```

* `abstract`方法：（必须重写）
* `new`方法（隐藏而非重写）：不能调用基类实现，无多态（编译时静态绑定）
```c#
class BaseClass {
    public void Show() { /*...*/ }
}

class DerivedClass : BaseClass {
    public new void Show() { /*...*/ } // 隐藏基类方法
}
```

## sealed class和方法
`sealed` 类是C#中不能被继承的类

## 接口
预定义接口，一些 C# 关键字甚至设计为与特定的预定义接口一起使用。语句和声明（在第 13 章中详细介绍）使用接口。此接口定义的方法不带任何参数，也不带返回类型。从此接口派生的类需要实现此方法：
```c#
public IDisposable
{
void Dispose();
}

// Resource实现了IDisposable接口
using (Resource resource = new())
{
// use the resource
}

// 相当于
Resource resource = new();
try
{
    // use the resource
}
finally
{
    resource.Dispose();
}
```

```c#
interface IShowable {
    void Show();
}

class MyClass : IShowable {
    public void Show() { /*...*/ } // 隐式实现
    void IShowable.Show() { /*...*/ } // 显式实现
}
```

readonly struct 是什么？


c# object.ReferenceEquals() 严格引用比较
重载==时应当保持与Equals()逻辑一致


## 委托（Delegate）和事件（Event）
Delegate就是C#的方法指针，
```c#
delegate void IntMethodInvoker(int x);
```

`Action<T>` and `Func<T>` 是内置的


委托可以包装多个方法。此类委托称为多播委托。调用多播委托时，它会按顺序连续调用每个方法。
```c#
public static class MathOperations
{
    public static void MultiplyByTwo(double value) => Console.WriteLine($"Multiplying by 2: {value} gives {value * 2}");
    public static void Square(double value) => Console.WriteLine($"Squaring: {value} gives {value * value}");
}

Action<double> operations = MathOperations.MultiplyByTwo;
operations += MathOperations.Square;
Action<double> operation1 = MathOperations.MultiplyByTwo;
Action<double> operation2 = MathOperations.Square;
Action<double> operations = operation1 + operation2;
```

匿名方法
```c#
Func<string, string> f = delegate(string s1) { return s1 + "sdd"; };

// 或者lambda写法
Func<string, string> f2 = s => "";
```

### 事件
事件基于委托，并为委托提供发布/订阅机制
```c#
// 内置事件委托
public delegate void EventHandler(object sender, EventArgs e);
```
用法：

使用`event`关键字，添加订阅者时，对象会自动生成，不需要我们手动创建。

1. 定义事件
```c#
public class Button
{
    // 1. 定义事件（使用 EventHandler 委托）
    public event EventHandler Click;
    
    // 2. 定义带自定义参数的事件
    public event EventHandler<string> TextChanged;
    
    // 3. 自定义事件参数
    public event EventHandler<ButtonClickEventArgs> ButtonClicked;

    // 触发事件的方法
    public void OnClick()
    {
        // 触发 Click 事件
        Click?.Invoke(this, EventArgs.Empty);
    }
    
    public void OnTextChanged(string newText)
    {
        TextChanged?.Invoke(this, newText);
    }
    
    public void OnButtonClicked(int clickCount)
    {
        ButtonClicked?.Invoke(this, new ButtonClickEventArgs { ClickCount = clickCount });
    }
}

// 自定义事件参数类
public class ButtonClickEventArgs : EventArgs
{
    public int ClickCount { get; set; }
}
```
> 事件也是委托，而委托就是函数指针包装，所以它可以调用`Invoke`方法

2. 订阅和使用事件
```c#
public class Program
{
    public static void Main()
    {
        var button = new Button();
        
        // 订阅事件
        button.Click += OnButtonClick;
        button.TextChanged += OnButtonTextChanged;
        button.ButtonClicked += OnButtonClicked;
        
        // 触发事件
        button.OnClick();
        button.OnTextChanged("Hello World");
        button.OnButtonClicked(5);
        
        // 取消订阅
        button.Click -= OnButtonClick;
    }
    
    // 事件处理方法
    private static void OnButtonClick(object sender, EventArgs e)
    {
        Console.WriteLine("按钮被点击了！");
    }
    
    private static void OnButtonTextChanged(object sender, string newText)
    {
        Console.WriteLine($"文本变为: {newText}");
    }
    
    private static void OnButtonClicked(object sender, ButtonClickEventArgs e)
    {
        Console.WriteLine($"按钮被点击了 {e.ClickCount} 次");
    }
}
```

## LINQ

## 自定义Attribute、反射、代码生成
相当于Java的注解

ISourceGenerator

## 内存管理
```c#
class MyClass {}  // 总是在堆上
struct MyStruct {} // 通常在栈上

void Example() {
    var c = new MyClass(); // 堆分配
    var s1 = new MyStruct(); // 栈分配
    
    MyStruct s2; // 也可以不用new，栈分配
    
    object boxed = s1; // 装箱操作，堆分配
}
```
结构体通常在栈上分配，但例外：
* 当结构体是类的成员时，会随类一起在堆上分配
* 当结构体被装箱(boxing)时，会在堆上分配
* 当结构体被捕获在闭包中时，会在堆上分配

在 C# 中，使用析构函数的推荐替代方法是使用 或 `IAsyncDiposable` 接口。这些接口定义了一种模式（具有语言级支持），该模式提供了一种确定性机制来释放非托管资源，并避免析构函数固有的与垃圾回收器相关的问题。`IDisposable` 接口声明了一个名为 `Dispose` 的单个方法，该方法不采用任何参数并返回。
```c#
public interface IDisposable
{
    void Dispose();
}

### unsafe
可以使用指针语法
fixed关键字，可以固定结构体在内存中的位置，避免在垃圾回收时被移动

```c#
MyClass myObject = new();
long* pL = &(myObject.X); // wrong -- compilation error
float* pF = &(myObject.F); // wrong -- compilation error


MyClass myObject = new();
fixed (long* pObject = &(myObject.X))
{
// do something
}
```

Delegate 是类，C#还提供了原始的 delegate* 指针类型，用于在不安全的代码中直接操作委托。

栈中创建数组：
```c#
decimal* pDecimals = stackalloc decimal[10];
```

# 库
NuGet