# 基础
## 变量和常量
变量默认是不可改变的，也可以使用 `mut` 关键字将其声明为可变的
```rust
let x = 5; // 不可变
let mut x = 5; // 可变
```

常量使用 `const` 关键字进行声明：
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
常量可以在任何作用域中声明，包括全局作用域，并且常量只能被设置为常量表达式

## 数据类型
Rust 是静态类型语言，并且支持类型推断。
```rust
let x = 1; // i32
let y = 1.5; // f64
let z: f32 = 2.0; // 显式指定为 f32

let t = true;
let f: bool = false;

let c = 'z';
let cc: char = 'ℤ';
```

Rust 的 `char` 类型的大小为四个字节，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。

### 复合类型
Rust 有两种主要的复合类型：元组（tuples）和数组（arrays）。

元组用法：
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;
let a = tup.0;
```

数组用法：
```rust
let a = [1, 2, 3, 4, 5];

let a: [i32; 5] = [1, 2, 3, 4, 5]; // 也可以显式指定类型和数量
```

语法糖：
```rust
let a = [3; 5];
// 等价于
let a = [3, 3, 3, 3, 3];
```

> Rust 的数组会在栈上分配

## 函数
```rust
fn plus_one(x: i32) -> i32 {
    x + 1 // 最后一行是表达式，没有分号，则 return 可以省略
}
```
如果添加分号，则是语句，就需要使用 `return` 关键字返回值

## 控制流

### if 语句
```rust
// if 语句
let number = 3;

if number < 5 {
    println!("condition was true");
} else {
    println!("condition was false");
}
```

因为 `if` 是**表达式** ，所以可以赋值给变量：
```rust
let condition = true;
let number = if condition { 5 } else { 6 };
```

### 循环
Rust 有三种循环：`loop`、`while` 和 `for`

`loop` 循环：
```rust
let mut counter = 0;

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;
    }
};
```

`while` 条件    循环：
```rust
let mut number = 3;

while number != 0 {
    println!("{number}!");

    number -= 1;
}
```

`for` 循环：
```rust
let a = [10, 20, 30, 40, 50];

for element in a {
    println!("the value is: {element}");
}

// 打印 0 到 99
for number in 0..100 {
    println!("{number}!");
}

// 打印 0 到 100
for i in 0..=100 {
    println!("{}", i);
}
```

### match 语句（相当于其他语言的 switch、when 语句）
```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

`match`还支持`if`：
```rust

```

# 枚举和模式匹配

```rust
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```


```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
```

## if let 和 let else 语法
```rust
fn main() {
    let some_value = Some(42);
    
    // 传统 match（啰嗦）
    match some_value {
        Some(x) => println!("值是: {}", x),
        None => {} // 什么都不做
    }
    
    // 使用 if let（简洁）
    if let Some(x) = some_value {
        println!("值是: {}", x);
    }
    // 如果是 None，就跳过
}
```


`let else`语法用于必须成功匹配的情况，如果失败就提前返回或执行其他操作。
```rust
fn get_username() -> Option<String> {
    Some("Alice".to_string())
    // 试试改成 None 看看会发生什么
}

fn main() {
    // 必须得到用户名，否则返回
    let Some(username) = get_username() else {
        println!("无法获取用户名");
        return;
    };
    
    println!("用户名: {}", username);
}
```

## while let
一个与 `if let` 结构类似的是 `while let` 条件循环，它允许只要模式匹配就一直进行 while 循环
```rust
let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("Popped: {}", top);
}
// 输出：
// Popped: 3
// Popped: 2
// Popped: 1
```

# 泛型 和 trait
## 泛型
```rust
// 泛型函数
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}


// 泛型结构体
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}

// 泛型枚举，比如经常使用的 Option<T>
enum Option<T> {
    Some(T),
    None,
}

// 泛型方法
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

> rust 的泛型，会对实际使用的情况生成各种类型对应的实现代码，类似C++模块，而不是Java的泛型。

## Trait
`Trait` 相当于其他语言的接口。

使用 `trait` 关键字来声明一个 trait：
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

实现 trait，在 `impl` 后添加 trait 的名称和 `for` 关键字：
```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```

### 默认实现
trait 可以提供方法的默认行为：
```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```
使用者如果完全不需要重新实现，就`impl Summary for NewsArticle {}`指定一个空的 impl 块即可。

### trait 作为参数类型
使用 `impl Trait` 语法，可以使用 trait 作为参数类型：

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// 相当于泛型方式
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

#### 指定多个 trait
```rust
pub fn notify(item: &(impl Summary + Display))

// 相当于泛型方式
pub fn notify<T: Summary + Display>(item: &T)
```

#### 使用 where 简化
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32

//  可以改为使用 where 的形式，看起来更清晰
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
```

### trait 作为返回类型
```rust
fn returns_summarizable() -> impl Summary {...}
```

### 关联类型
Iterator trait 的定义如下
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

实现使用如下：
```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--

```

这种语法看起来与泛型类似，为什么不用泛型来定义 Iterator trait 呢？**因为如果使用泛型，就可以有多个针对 Counter 的 Iterator 的实现，当我们在 Counter 上调用 next 方法时，就必须通过类型注解来指明要使用哪一个 Iterator 的实现。而使用关联类型，则无需标注类型，因为不能对同一个类型多次实现该 trait。**

### 常用 trait
* `Drop` 用于当一个值的所有权结束（离开作用域、或被 drop 函数手动销毁）时，自动执行开发者定义的清理操作。
* `Deref` 用于支持解引用运算符
* `Clone` 定义类型的 “深拷贝” 逻辑，允许从一个已有值创建出一个独立的、拥有完整所有权的新值（拷贝后新旧值互不影响

比如 String 实现了 Clone trait 
```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {s1}, s2 = {s2}");
```
其他例如 Vec、Box 也实现了 Clone trait 

# 控制权
在无GC的语言中，有C、C++这种手动回收对象的方式，也有OC、Swift这种在引用计数为0的时候回收的方式（引用计数也有少量的运行时开销，比如引用计数增减是原子操作，额外内存开销）。

而`Rust`通过所有权系统来确定释放内存的时机，我们来推演一下，设定如下限制：
* 限制1：在变量结束作用域后立即回收
* 限制2：因为要遵循限制1，如果多个变量赋值共享一个对象会有重复回收的问题，所以一个变量仅和一个对象绑定
* 限制3：因为要遵循限制2，所以赋值移动后，原变量不能再使用

所以`Rust`设定的所有权规则有3条：
1. Rust 中的每一个值都有一个**所有者**（owner）
2. 值在任一时刻有且只有一个所有者（禁止共享）
3. 当所有者离开作用域，这个值将被丢弃（安全释放资源）

比如这个作用域结束的例子：
```rust
{
        let s = String::from("hello"); // 从此处起，s 是有效的

        // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
```
当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop` （相当于Rust的析构函数）。在该函数中 String 的作者可以放置释放内存的代码。


如下是赋值操作，所有权转移的例子：
```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被转移给 s2，之后 s1 不能再使用
```

## Copy trait
Rust 有一个叫做 `Copy trait` 的特殊接口，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 `Copy trait`，那么一个旧的变量在将其赋值给其他变量后仍然有效。**因为这种类型会直接复制，不会发生所有权转移**。

如下是一些 Copy 的类型：
* 所有整数类型，比如 u32。
* 布尔类型，bool，它的值是 true 和 false。
* 所有浮点数类型，比如 f64。
* 字符类型，char。
* 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
* 一个数组 [T; N] 实现 Copy Trait 的前提是：它的元素类型 T 必须实现 Copy Trait。

所以总的来说就是：
* **Copy 类型：赋值 = 复制**
* **非 Copy 类型：赋值 = 移动所有权**


会转移所有权的情况：
* 赋值给新变量（非 Copy 类型）
* 传递给函数（非引用参数）
* 从函数返回
* for i in collection（使用 into_iter()）
* 模式匹配和解构

不会转移所有权的情况：
* 使用引用 (&, &mut)
* for i in &collection（使用 iter()）
* for i in &mut collection（使用 iter_mut()）
* Copy 类型的操作

> 对象控制权在`Swift`中也有类似的概念，比如`inout`、`consuming`、`borrowing`，但`Swift`中并不是强制的。而 `Rust` 中是强制使用的，在编译器就会检查是否符合所有权规则。

## 所有权与函数
函数传参和赋值一样，会转移控制权。除非是 Copy 类型，比如基本类型。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
    println!("{}", x);              // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{some_string}");
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{some_integer}");
} // 这里，some_integer 移出作用域。没有特殊之处
```


```rust
fn main() {
    let s1 = gives_ownership();        // gives_ownership 将它的返回值传递给 s1

    let s2 = String::from("hello");    // s2 进入作用域

    let s3 = takes_and_gives_back(s2); // s2 被传入 takes_and_gives_back, 
                                       // 它的返回值又传递给 s3
} // 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生
  // s1 移出作用域并被丢弃

fn gives_ownership() -> String {       // gives_ownership 将会把返回值传入
                                       // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域

    some_string                        // 返回 some_string 并将其移至调用函数
}

// 该函数将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String {
    // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

**变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会转移。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。**

## 引用和借用
上面介绍将变量传入函数，变量的所有权转移到了函数内部，调用方的后续代码无法再使用该变量。所以rust提供了`引用`类型，它本质是一个受限制的指针，并不拥有这个变量的所有权。

### 引用
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize { // s 是 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
```
`&` 引用，允许你使用值但不获取其所有权。我们将创建一个引用的行为称为 `借用（borrowing）`。这种情况是不可变引用，不能修改借用的变量。

### 可变引用
使用 `&mut` 可以创建可变引用。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
但可变引用有一个很大的限制：**如果你有一个对该变量的可变引用，同一时间（或者说在可变引用的作用域内），你就不能再创建对该变量的引用（无论是可变还是不可变）**

这样做的目的是：
* 防止数据竞争和逻辑错误
* 保证引用的一致性（不可变引用真的“不可变”）
* 在零成本抽象下实现内存安全

### 悬垂引用和生命周期
由于引用只是一个指针，在函数中创建的引用，当函数返回时，会存在悬垂引用问题，因为函数内的 `s` 在结束作用域后会被释放，返回它的引用会存在问题。所以 Rust 会通过一个编译时错误来防止它：

```rust
// ❌ 编译报错：
fn dangle() -> &String { // dangle 返回一个字符串的引用

    let s = String::from("hello"); // s 是一个新字符串

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险


// ✅ 例如可以改为普通类型：
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
如果一定要返回引用，则需要了解下面介绍的生命周期、全局静态变量的引用 `&'static` 和智能指针`Box<T>`等概念。

## 生命周期
rust 中的每一个引用都有其生命周期，也就是引用保持有效状态的作用域。大部分时候生命周期是隐含并可以推断，但也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

```rust
// ❌ 编译失败
fn main() {
    let r;                // ---------+-- `a
                          //          |
    {                     //          |
        let x = 5;        // -+-- `b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```
Rust 编译器有一个借用检查器（borrow checker），假设 `r` 的生命周期是 `a` ，`x` 的生命周期是 `b`，程序会被拒绝编译，因为生命周期 `b` 比生命周期 `a` 要小：被引用的对象比它的引用者存在的时间更短。

再看看可以正确编译的情况：
```rust
// ✅ 正确情况：
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

### 生命周期标注
前面介绍在函数中传入引用，但是没有介绍如果要返回引用的问题，如果直接返回引用会报错。

查看如下情况：
```rust
// ❌ 错误情况：
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```
这种情况，编译器并不知道 x 和 y 的生命周期是如何与返回值的生命周期相关联的，假如返回的引用和 x、y 没有关联，那就是悬垂引用，必然错误。又假如返回的引用和 x、y 有关联，也就是说返回引用的生命周期和x、y 的生命周期相同，那么返回的引用就是有效的，但是编译器无法确定这个情况。此时，就需要使用生命周期标注语法，用来告诉编译器返回的引用和传入参数的生命周期关联性。

生命周期语法并不改变任何引用的生命周期的长短，只是描述多个引用生命周期相互的关联。生命周期参数名称必须以撇号 `'`开头，其名称通常全是小写
```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

那么现在看看在函数中使用情况：
```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```
x、y 和返回的引用都标记了 `a，表达的意思就是：这两个参数和返回的引用存活的一样久。并且返回的引用必须来自标记了相同生命周期 'a 的传入参数（或不短于 'a 的生命周期的数据，比如 'static 生命周期）

使用的时候如下：
```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```
`string1` 直到外部作用域结束都是有效的，`string2` 则在内部作用域中是有效的，而根据 `longest` 函数的生命周期标注，编译器可以确认 `result` 引用了一些直到内部作用域结束都是有效的值，要么是`string1`或者`string2`或者基于它们的引用再产生的引用（比如调用`str.trim()`），要么就是全局静态变量，这几种可能情况下，`result` 都不会造成悬垂引用，所以编译器可以通过编译。


也可以说 `result` 的引用的生命周期是两个参数中较短的那个，也就是生命周期的交集，因为最短的没问题就都没问题，所以如下代码不能通过编译：
```rust
// ❌ 无法编译
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```
因为 `result` 引用的可能是 `string2`，内部作用域结束后，`string2` 已经被释放，所以在内部作用域结束后不能使用 `result`。

#### 生命周期标注的更多用法

1. 比如返回值的引用只和一个参数有关，就可以只标记一个参数的生命周期。
```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```


2. 结构体中使用生命周期语法：
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

### 静态生命周期
`'static` 其生命周期能够存活于整个程序期间

```rust
let s: &'static str = "I have a static lifetime.";
```


### 生命周期语法也是泛型
生命周期语法和泛型一起使用时，如下：
```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}
```

## Slice
切片（slice）允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它不拥有所有权。

字符串 slice 是 String 中一部分值的引用，它看起来像这样：
```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11]; // world 是一个包含指向 s 索引 6 的指针和长度值 5 的 slice。

// 如果想要从索引 0 开始，可以不写两个点号之前的值
let slice = &s[0..2];
// 等同于
let slice = &s[..2];


let len = s.len();
// 如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字
let slice = &s[3..len];
// 等同于
let slice = &s[3..];

let slice = &s[0..len];
// 等同于
let slice = &s[..];
```

字符串字面值也是 slice
```rust
let s = "Hello, world!"; // 类型是 &str，是一个不可变引用
```

函数中传入字符串参数，一般会使用字符串slice类型 `&str`。因为可以直接接收三种常见输入，无需任何转换：
* 字符串字面量（&'static str）：如 "hello world"；
* String 的引用（&String）：Rust 自动将 &String 强制转换为 &str（Deref 强制转换）；
* 字符串切片（&str 片段）：如 &"hello rust"[0..5]。


数组也可以使用 slice：
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```

## 闭包和控制权
闭包语法为：|参数1, 参数2, ...| -> 返回值类型 { 函数体 }
```rust
fn main() {
    // 1. 无参数、无返回值（最简形式）
    let print_hello = || println!("Hello, Closure!");
    print_hello(); // 调用：输出 "Hello, Closure!"

    // 2. 单参数、无显式类型（编译器推断参数为 i32，返回值为 i32）
    let double = |x| x * 2;
    println!("{}", double(5)); // 输出 10

    // 3. 多参数、显式标注类型（类似普通函数，可选）
    let add = |a: i32, b: i32| -> i32 { a + b };
    println!("{}", add(3, 4)); // 输出 7

    // 4. 多表达式函数体（必须用 {}，需显式 return 或让最后一个表达式作为返回值）
    let compute = |x: i32| {
        let y = x * 2;
        y + 3 // 最后一个表达式作为返回值（无需 return）
    };
    println!("{}", compute(4)); // 输出 11
}
```


闭包可以通过三种方式捕获其环境中的值，它们直接对应到函数获取参数的三种方式：`不可变借用`、`可变借用`和`获取所有权`。闭包将根据函数体中对捕获值的操作来决定使用哪种方式。

```rust
// 定义了一个捕获名为 list 的 vector 的不可变引用的闭包，因为只需不可变引用就能打印其值
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}


// 闭包体向 list vector 增加一个元素，所以闭包会捕获一个可变引用
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}
```

如果希望强制闭包获取它在环境中所使用的值的所有权，可以在参数列表前使用 `move` 关键字。
```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
```

### 闭包的类型
Rust 的闭包是匿名类型（编译器在编译期为每个闭包生成唯一的匿名类型，无法显式写出），但所有闭包都实现了以下三个 Trait 之一（根据捕获方式自动实现）：
1. `Fn(&self)`：不可变捕获（&T 或 Copy），闭包可被多次调用，不修改捕获的变量
2. `FnMut(&mut self)`：可变捕获（&mut T），闭包可被多次调用，可修改捕获的变量
3. `FnOnce(self)`：所有权捕获（T，如 move 闭包），闭包只能被调用一次（调用后消耗自身）

由于闭包是匿名类型，无法直接作为函数参数类型，因此通常用 Fn/FnMut/FnOnce 作为 trait bound 约束：
```rust
// 1. 接收 Fn 闭包（不可变捕获，可多次调用）
fn call_fn<F: Fn()>(f: F) {
    f();
    f(); // 可多次调用
}

// 2. 接收 FnMut 闭包（可变捕获，可多次调用）
fn call_fn_mut<F: FnMut()>(mut f: F) {
    f();
    f(); // 可多次调用（闭包需可变）
}

// 3. 接收 FnOnce 闭包（所有权捕获，只能调用一次）
fn call_fn_once<F: FnOnce()>(f: F) {
    f();
    // f(); // 编译报错：FnOnce 只能调用一次
}
```

## 迭代器和控制权
```rust
let v = vec![String::from("a"), String::from("b")];

// 这行代码：
for item in v { // 
    // ...
}

// 实际上被编译器转换为：
let mut iterator = v.into_iter();  // into_iter() 消耗了 v，因为该函数声明为  fn into_iter(self) ，会移动控制权
while let Some(item) = iterator.next() {
    // ...
}
```

两外两种使用引用的迭代方式，则不会转移控制权
```rust
for item in &v { // 使用 iter()，不可变借用。函数声明为： fn iter(&self)
    // ...
}


for item in &mut v { // 使用 iter_mut()，可变借用。函数声明为： fn iter_mut(&mut self)
    // ...
}
```

## 智能指针
引用和智能指针的重要区别：引用只会借用数据，并不拥有数据，必须依附于被引用对象的生命周期；而智能指针可以拥有它们指向的数据，并且将数据分配在堆上。

在 Rust 中，你需要显式选择将对象放在堆上（例如使用 Box），而不是像某些语言那样所有对象都在堆上，这给了你更多的控制权和性能优化机会。

### Box<T>
`Box<T>` 是 Rust 最基础的智能指针，核心功能是：
1. **堆分配**：把原本默认存在栈上的数据，放到堆上存储
2. **所有权管理**：`Box<T>` 本身（一个指针）存在栈上，它拥有堆上数据的所有权 —— 当 `Box<T>` 离开作用域时，会自动调用 drop 方法，释放堆上的内存（无需手动管理，避免内存泄漏）。


这里的代码会在堆上存储一个 `i32` 值
```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```
当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）。

就像C语言的结构体不能直接定义递归结构，而需要借助指针一样，rust 中可以借助 box 来定义递归结构：
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

总结一下需要使用`Box<T>`的主要场景：
1. 存储 “大小不确定” 的类型（动态大小类型 DST），比如链表
2. 转移大对象的所有权（避免栈拷贝开销）
3. 使用`Box<dyn Trait>`实现动态的多态（不过也可以使用`&dyn Shape`、`T: Shape`、`impl Shape`的方式实现多态）
```rust
// Box<dyn Trait> 例子：

// 定义一个 trait
trait Shape {
    fn area(&self) -> f64;
}

// 实现两个具体类型
struct Circle(f64); // 半径
struct Square(f64); // 边长

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.0 * self.0
    }
}

impl Shape for Square {
    fn area(&self) -> f64 {
        self.0 * self.0
    }
}

// 函数接收 trait 对象 Box<dyn Shape>，支持所有实现了 Shape 的类型
fn print_area(shape: Box<dyn Shape>) {
    println!("面积：{}", shape.area());
}

fn main() {
    let circle = Box::new(Circle(2.0));
    let square = Box::new(Square(3.0));
    
    print_area(circle); // 输出 12.566...
    print_area(square); // 输出 9.0
}
```
-------------------

`Box<T>` 和引用不是对立关系，而是互补关系 —— 你可以通过解引用（*）获取 `Box<T>` 内部数据的引用，也可以把引用指向 `Box<T>` 管理的堆数据。下面介绍一些引用和`Box<T>`配合使用的例子。

`Box<T>` 实现了 `Deref trait`，支持解引用`*`，因此可以直接通过 `&*boxed` 或 `&mut *boxed` 获取内部数据的引用：
```rust
fn main() {
    let boxed = Box::new(5); // 堆上存储 5，栈上存指针
    
    // 获取不可变引用（&i32）
    let ref1 = &boxed; // 类型为 &Box<T>
    let ref2: &i32 = &boxed; // 类型为 &i32，自动解引用
    let ref3 = &*boxed; // 类型为 &i32，手动解引用

    // 获取值
    let val1 = *boxed; // 类型为 i32，手动解引用
    let val2 = **ref1 + ref2; // ref1需要解两次引用，才能得到内部的值，第一次解引用得到 Box<i32>，第二次才得到 i32


    // 获取可变引用（&mut i32）
    let mut boxed_mut = Box::new(5);
    *boxed_mut = 2; // 直接解引用修改值
    let ref_mut = &mut *boxed_mut;
    *ref_mut = 6; // 通过可变引用修改堆上的数据
    println!("boxed_mut: {}", boxed_mut); // 输出 6
    let ref_mut2: &mut i32 = boxed_mut.as_mut(); // 通过 as_mut 方法获取可变引用，等价于 let ref_mut2 = (&mut boxed_mut).as_mut();

}
```
这里的 `ref1`、`ref_mut` 依赖 `boxed/boxed_mut` 的生命周期（boxed 失效后，引用也会失效），遵循引用的生命周期规则。

自动解引用：
```rust
fn print_value(x: &i32) {
    println!("{}", x);
}

let boxed = Box::new(5);
let ref1 = &boxed; // 类型为 &Box<T>
print_value(ref1); // 可以自动解引用为 &i32
```
但前面的加法例子没有完成自动解引用，而是手动解两次引用。因为编译器虽然能通过 Deref 把 `&Box<i32>` 转成 `&i32`，但它不会“主动猜测”你想把 `&Box<i32>` 转成 &i32 再和 i32 相加，除非上下文能明确 “期望的类型”。这种情况只能手动解引用或者显式标注类型


### Deref Trait
实现 `Deref trait` 允许我们定制解引用运算符（dereference operator）`*`，

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x); // ✅
    assert_eq!(5, *y); // ✅
    assert_eq!(5, y); // ❌ 编译错误，不允许比较数字的引用与数字，必须使用解引用运算符追踪引用所指向的值
}
```

`Box<T>`也可以像引用一样使用解引用运算符：
```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
为了启用 `*` 运算符的解引用功能，需要实现 `Deref trait`，而 `Box<T>` 默认实现了 `Deref trait`。

比如我们自己实现 `Deref`：
```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T; // 

    fn deref(&self) -> &Self::Target {
        &self.0 // 返回元组结构体的第一个元素
    }
}
```
对实现`Deref trait`的类型解引用，实际就是执行 `*(y.deref())`

### Drop Trait
指定在值离开作用域时应该执行的代码的方式是实现 `Drop trait`，包含一个 `drop` 方法，相当于析构函数。你不需要手动调用 `drop` 方法。Rust 编译器会在变量离开作用域时，自动插入调用 `drop` 方法的代码。

不过日常 Rust 开发中，几乎不需要自己手动实现 Drop Trait——Rust 标准库的绝大多数类型（如 `String`、`Vec<T>`、`Box<T>`、`File`、`MutexGuard` 等）都已经实现了 Drop，会自动管理内存、文件句柄、锁等资源，无需手动干预。

在少数情况，比如持有 unsafe 指针、持有外部资源句柄（比如数据库连接）或者其他自定义清理逻辑的时候，才需要自己去实现 Drop trait。

### Rc<T> 引用计数智能指针
有些情况单个值可能会有多个所有者，在有至少一个所有者时，都不应该被清理，为了启用多所有权需要显式地使用 Rust 类型 `Rc<T>`，其为引用计数（reference counting）的缩写。

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    // b 和 c 内部都指向了同一个 a
    let b = Cons(3, Rc::clone(&a)); // 克隆 Rc（不是克隆数据！）
    let c = Cons(4, Rc::clone(&a));
}
```
`Rc::clone(&x)` 只是增加引用计数，不复制数据，当最后一个 Rc 被 drop 时，数据才被清理。

> `Rc<T>` 不是线程安全的，多线程间共享，应使用 `Arc<T>`（Atomic Reference Counting）


有一些场景，`Box<T>`无法使用，需要使用`Rc<T>`：

**场景1：多个变量共享一个 Box<T>**

```rust
struct ComponentA {
    config: Box<String>,
}

// 组件 B：也持有配置的引用
struct ComponentB {
    config: Box<String>,
}

fn main() {
    let component_a: ComponentA;
    let component_b: ComponentB;

    // Box 是配置的所有者（作用域内存活）
    let boxed_config = Box::new("db_url: localhost".to_string());

    // 组件 A 和 B 持有引用
    component_a = ComponentA {
        config: boxed_config, // 控制权移交给 ComponentA
    };
    component_b = ComponentB {
        config: boxed_config, // ❌ 报错：无法使用已经转移控制权的变量
    };
}
```
虽然这里可以改为使用引用，但又会存在悬垂引用的问题：
```rust
// 组件 A：持有配置的引用
struct ComponentA<'a> {
    config: &'a String,
}

// 组件 B：也持有配置的引用
struct ComponentB<'a> {
    config: &'a String,
}

fn main2() {
    let component_a: ComponentA;
    let component_b: ComponentB;

    {
        // Box 是配置的所有者（作用域内存活）
        let boxed_config = Box::new("db_url: localhost".to_string());

        // 组件 A 和 B 持有引用
        component_a = ComponentA { config: &boxed_config };
        component_b = ComponentB { config: &boxed_config };
    }
    // 此时 boxed_config 已销毁（作用域结束），component_a/config 变成悬垂引用

    // ❌ 编译报错：component_a 和 component_b 的生命周期比 boxed_config 长
    println!("ComponentA: {}", component_a.config);
}
```

**场景2:双向引用**
```rust
// 尝试用 Box + 引用实现双向链表 → 编译报错
struct Node<'a> {
    value: i32,
    next: Option<Box<Node<'a>>>, // 下一个节点（Box 所有权）
    prev: Option<&'a Node<'a>>,  // 上一个节点（引用）
}

fn main() {
    let mut node1 = Box::new(Node {
        value: 1,
        next: None,
        prev: None,
    });

    let node2 = Box::new(Node {
        value: 2,
        next: None,
        prev: Some(&node1), // 引用 node1
    });

    // 尝试让 node1 的 next 指向 node2 → 编译报错
    node1.next = Some(node2); // ❌ 错误：node1 已经存在引用，无法再修改它。（并且生命周期循环依赖，编译器无法验证安全性）
}
```

**只要有任何活跃引用（也就是借出了变量），无论是 & 还是 &mut，都不能直接修改原变量。如果要修改只能通过 &mut 来修改，或者等引用的作用域结束：**
```rust
// 假设这是合法的（实际 Rust 不允许！）
let mut x = 5;
let r = &x;      // r 是 x 的“快照”
x = 10;          // ❌ 修改 x
println!("{}", *r); // 输出什么？5 还是 10？

let r2 = &mut x;
x = 2; // ❌ r2还在作用域，x 还处于借出状态，无法访问
*r2 = 3; // ✅ 通过 &mut 可以修改

x = 2; // ✅ 假设后面不再使用 r 和 r2 ，则可以直接修改原变量
```
* 如果输出 5 → 那 r 就不是指向 x，而是拷贝了一份（但 &x 明明是引用！）
* 如果输出 10 → 那 r 就不是“不可变”的，它看到的值变了！

这就破坏了 “不可变引用”（immutable reference）的语义

### RefCell<T>
`RefCell<T>` 是 Rust 中用于实现 “内部可变性（Interior Mutability）” 的核心工具。它的作用是：即使在不可变引用（`&T`）的情况下，也能修改其内部的数据。它会通过 运行时检查（而非编译期检查） 来保证内存安全。

先看一下基本使用：
```rust
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5); // x 是不可变绑定！

    // 即使 x 不可变，也能修改内部值
    *x.borrow_mut() = 10;

    println!("{}", x.borrow()); // 输出 10
}
```
* `.borrow()` → 获取不可变引用（类似 &T）
* `.borrow_mut()` → 获取可变引用（类似 &mut T）

`RefCell<T>`结合`Rc<T>`使用的场景：
```rust
use std::rc::Rc;
use std::cell::RefCell;

let shared = Rc::new(RefCell::new(0));
let a = Rc::clone(&shared);
let b = Rc::clone(&shared);

*a.borrow_mut() += 1;
*b.borrow_mut() += 1;

println!("{}", *shared.borrow()); // 2
```

使用`RefCell<T>`配合`Rc<T>`可以实现双向链表，这是使用`Box<T>`无法实现的（除非使用原始指针）


`RefCell<T>`打破了“不可变绑定 = 不可变数据”的限制，使得 Rust 能在以下情况灵活应对：
* 共享所有权下的可变需求（配合 Rc）
* 回调、闭包中的状态更新
* 编译器无法推断的安全可变场景

> 为什么 Rust 不干脆只用 `Rc<T>`和 `RefCell<T>`，而还要保留 `Box<T>` 呢？答案是：因为 `Rc<T>`和 `RefCell<T>` 有代价，而 `Box<T>` 更简单、高效、语义清晰。Rust 的设计哲学是“零成本抽象”和“明确表达意图”，所以要根据场景选择最合适的工具。
Box开销小、编译期检查、线程安全、单一所有权更清晰

### `Mutex<T>` 和 `RwLock<T>`
`Mutex<T>`、`RwLock<T>` 和 `RefCell<T>` 都是用来实现 “内部可变性（Interior Mutability）” 的工具，但它们适用于完全不同的场景。

* `RefCell<T>`：单线程使用，典型用法为 `Rc<RefCell<T>>`
* `Mutex<T>`：多线程互斥，典型用法为 `Arc<Mutex<T>>`
* `RwLock<T>`：多线程读写锁，典型用法为 `Arc<RwLock<T>`

### Weak<T> 弱引用
在使用`Rc<T>`或 `Arc<T>`时，如果需要避免循环引用，可以使用`Weak<T>`。

```rust
use std::rc::{Rc, Weak};

let strong = Rc::new(42);
let weak = Rc::downgrade(&strong); // 创建 Weak 引用

// 从 Weak 获取数据（尝试升级）
if let Some(strong_again) = weak.upgrade() {
    println!("Value: {}", strong_again);
} else {
    println!("Data has been dropped!");
}

// 检查是否已失效
println!("Weak is alive? {}", weak.strong_count() > 0);
```

* Weak 不能直接解引用，需要使用`upgrade()`得到 `Option<Rc<T>>`
* 从`Arc<T>`创建的 Weak 才能保证线程安全。


# 结构体
```rust
// 定义结构体
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

// 使用结构体
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    // 修改结构体，所以需要声明 user1 是可变变量
    user1.email = String::from("anotheremail@example.com");
}
```

## 结构体更新语法糖
```rust
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
```
`..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。`..user1` 必须放到最后

## 元组结构体
元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    let Point(x, y, z) = origin; // 将 origin 的值解构到名为 x、y 和 z 的变量中
}
```

## 方法语法
使用 `impl` 来定义方法：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
这里为什么用 &？ 


## 关联函数
所有在 `impl` 块中定义的函数被称为 关联函数，而 `impl` 中不以 `self` 为第一参数的关联函数（也就不是方法，感觉相当于静态函数），经常被用作返回一个结构体新实例的构造函数。比如 `String::from` 函数。

比如自己定义一个 `square` 构造函数：
```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}

// 使用方式
let sq = Rectangle::square(3);
```

# 包和模块
## 包和Crate
`crate` 是 Rust 在编译时最小的代码单位。即使你用 rustc 而不是 cargo 来编译一个单独的源代码文件，编译器还是会将那个文件视为一个 crate。crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译。相当于 Java 的 jar 包。

`包` 是包含一个或多个 `crate` 的集合。一个包会包含一个 Cargo.toml 文件，阐述如何去构建这些 crate。

## 模块
`rust`中的每个源文件都是一个模块，模块的「路径层级」与文件的「目录层级」完全对应。

例如这样的目录结构：
```
src/
├── main.rs          # 入口模块（根模块 crate::）
├── utils.rs         # 模块：crate::utils
└── network/
    └── http.rs      # 模块：crate::network::http
```

`main.rs`中要使用`utils`模块中的内容，需要这样导入：
```rust
mod utils;
mod network { // 创建了一个内联模块
    pub mod http; // 这样会查找 src/network/http.rs
}

fn main() {
    utils::print_message();
    network::http::send_request();
}
```

也可以在目录中使用 `mod.rs` ，它告诉 Rust："这个文件夹是一个模块，我是它的主文件"。
```
src/
└── network/          # 现在这是一个模块
    ├── mod.rs        # ⭐ 模块入口文件
    └── http.rs
```

然后在 `network/mod.rs` 中添加代码：
```rust
// 功能1:声明子模块
// src/network/mod.rs
pub mod http;      // 声明 http 子模块


// 功能2:定义模块内容
// 可以直接在 mod.rs 中定义函数、结构体等
pub fn connect() {
    println!("网络连接");
}

// 功能3:重新导出模块内容，简化外部使用
pub use http::HttpClient; // 外部可以这样用：network::HttpClient 而不是 network::http::HttpClient
```

目录和源文件同名的情况：
```
src/
├── network.rs       # network 模块
└── network/         # network 的子模块
    ├── http.rs
```
可以直接在 `network.rs` 中查找 network 目录中的 `http.rs`
```rust
// src/network.rs
pub mod http;  // 查找 src/network/http.rs
```

还可以在源文件中创建子模块：

文件目录结构：
```
src/
├── kitchen.rs
└── main.rs
```

在 `kitchen.rs` 文件中添加子模块：
```rust
pub mod kitchen {           // 创建 kitchen 模块
    pub mod chef {          // 在 kitchen 内创建 chef 子模块
        pub fn cook_food() {
            println!("大厨做饭");
        }
    }
    
    pub mod waiter {        // 在 kitchen 内创建 waiter 子模块
        pub fn serve_food() {
            println!("服务员上菜");
        }
    }

    // 在 kitchen 模块内直接访问子模块
    pub fn restaurant_work() {
        chef::cook_food();     // 直接访问，不需要前缀
        waiter::serve_food();  // 直接访问
    }
}
```

在 `main.rs` 中使用 `kitchen` 模块：
```rust
mod restaurant;

fn main() {
    restaurant::kitchen::chef::cook_food();
    restaurant::kitchen::waiter::serve_food();
}
```

### 模块使用总结
* 创建模块：创建 `.rs` 文件，或在文件夹中创建 `mod.rs`,
* 声明模块：使用 `mod` 模块名，引入模块
* 设置权限：用 `pub` 控制谁可以访问
* 使用模块：用 `use` 创建快捷方式，`as` 可以定义别名

看到 mod xxx;（带分号）→ 这是在引入外部文件
看到 mod xxx { ... }（带花括号）→ 这是在定义内部模块

# 集合
String 和 Vec 都在堆上分配内存，使用的是和 Box 相同的堆分配机制API，虽然不是直接使用 Box，不过本质一样

## Vector
`Vec<T>` 的数据存储在堆中，但 Vec 本身的结构（比如长度）在栈中。

```rust
let v: Vec<i32> = Vec::new(); // 创建 Vec
let v = vec![1, 2, 3]; // 使用 vec! 宏创建 Vec，可以省略类型

let mut v = Vec::new();
v.push(5);
v.push(6);

let a: i32 = v[0]; // 通过索引会得到该位置的值
let b: Option<&i32> = v.get(1); // 通过 get 得到的是 Option<&T> 类型。这样可以避免数组越界，相当于 getOrNull 方法
```

遍历 vec ：
```rust
// 读取 vec 中的元素
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}

// 修改 vec 中的元素
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```
这里使用 `&` 引用，因为不需要复制，更高效，并且没有移动所有权，v之后还可以使用

### Vec 释放
`vector` 在其离开作用域时会被释放，当 `vector` 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。

## 字符串
String 本质是一个 `Vec<u8>` 的封装

## Map
`HashMap<K, V>`用法：
```rust
 use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
// get 方法返回 Option<&V>，通过调用 copied 方法来获取一个 Option<i32> 而不是 Option<&i32>，
// 调用 unwrap_or 在 scores 中没有该键所对应的项时将其设置为零
let score = scores.get(&team_name).copied().unwrap_or(0);

// 遍历
for (key, value) in &scores {
    println!("{key}: {value}");
}
```

# 错误处理
Rust 将错误分为两大类：可恢复的（recoverable）和 不可恢复的（unrecoverable）错误。Rust 没有异常。相反，它有 `Result<T, E>` 类型，用于处理可恢复的错误，还有 `panic!` 宏，在程序遇到不可恢复的错误时停止执行。

## 使用 `panic!`
执行会造成代码 `panic` 的操作（比如访问超过数组结尾的内容）或者显式调用 `panic!`，都可以造成 panic。
```rust
fn main() {
    panic!("crash and burn"); // 主动 panic

    // 或者数组越界
    let v = vec![1, 2, 3];
    v[99];
}
```

## 使用 Result
Rust 没有传统的 try-catch 机制的，而是使用返回 `Result` 类型的方式处理错误。


比如 `File::open` 就会返回 `Result` 类型：
```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            _ => {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}
```


`Result<T, E>` 类型定义了很多辅助方法来处理各种更为特定的任务。`unwrap` 方法是一个快捷方式，如果 Result 值是变体 Ok，unwrap 会返回 Ok 中的值。如果 Result 是变体 Err，unwrap 会为我们调用 panic!。比如：
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

`expect` 方法也允许我们自定义 panic! 的错误信息。使用 expect 而不是 unwrap 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。expect 的语法看起来像这样：
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

### 传播错误
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

#### 传播错误的快捷方式：? 运算符
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```
Result 值之后的 `?` ，如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。如果值是 Err，Err 将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。


# 并发和 Async、Await
## 线程

### 创建线程
`thread::spawn`可以创建线程，它会返回一个`JoinHandle`，可以用来等待线程执行完毕。
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let thread_join_handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap(); // join() 方法返回一个 thread::Result<T>
}
```
> 生成新线程的线程与被生成线程之间没有父子关系

### 线程配置
创建线程时，可以使用`Builder`来配置线程，比如设置线程的名称和栈大小。
```rust
use std::thread;

thread::Builder::new().name("thread1".to_string()).spawn(move || {
    println!("Hello, world!");
});
```

获取线程对象：
```rust
let thread = thread_join_handle.thread(); // 通过 JoinHandle 得到 &Thread 引用

let current_thread = thread::current(); // 获取当前线程对象 Thread 类型
```

### thread::scope
Rust 的 `thread::scope` 方法（作用域线程）是 Rust 1.63+ 引入的核心功能，核心作用是：创建一组 “受作用域约束” 的子线程，确保所有子线程在作用域结束前完成，且子线程可安全引用作用域内的栈数据（无需 'static 生命周期）。

它解决了普通 `thread::spawn` 的两个核心痛点：
1. 普通线程要求捕获的变量必须满足 `'static`（无法直接引用栈上临时数据），除非使用 `move`
2. 需手动 join 所有线程，否则可能出现主线程退出、子线程被强制终止的问题。

```rust
use std::thread;

fn main() {
    let stack_data = "栈上的临时数据".to_string();

    // 1. 定义线程作用域，作用域结束前所有子线程必须完成
    thread::scope(|s| {
        // 2. 在作用域内创建子线程，可直接引用 stack_data
        s.spawn(|| {
            println!("子线程1访问：{}", stack_data);
        });

        // 3. 可创建多个子线程，均能安全引用作用域内数据
        s.spawn(|| {
            println!("子线程2访问：{}", stack_data);
        });
    }); // 4. 作用域结束：自动等待所有子线程完成，无需手动 join

    println!("所有子线程已完成，主线程继续");
}
```
Rust 编译器能保证：**作用域内的所有子线程一定在作用域结束前完成，因此栈数据不会被提前销毁，避免悬垂引用。**

普通线程需手动调用 `handle.join()` 等待完成，而 `scope` 会在作用域结束时，自动阻塞主线程，直到所有子线程执行完毕 —— 无需管理线程句柄，代码更简洁。

### 线程本地存储
简单的例子：
```rust
use std::thread;
use std::cell::RefCell;

// 1. 用 thread_local! 宏定义线程本地变量
//    - RefCell 用于实现“线程内可变”（TLS 变量默认不可变）
//    - 初始值为空字符串
thread_local! {
    static THREAD_LOCAL_STR: RefCell<String> = RefCell::new(String::new());
}

fn main() {
    // 2. 主线程操作 TLS 变量
    THREAD_LOCAL_STR.with(|s| {
        // 解包 RefCell 并修改（线程内可变）
        s.borrow_mut().push_str("主线程的内容");
        println!("主线程 TLS 内容：{}", s.borrow()); // 输出：主线程的内容
    });

    // 3. 子线程 1 操作 TLS 变量（独立副本）
    let handle1 = thread::spawn(|| {
        THREAD_LOCAL_STR.with(|s| {
            s.borrow_mut().push_str("子线程1的内容");
            println!("子线程1 TLS 内容：{}", s.borrow()); // 输出：子线程1的内容
        });
    });

    // 4. 子线程 2 操作 TLS 变量（另一独立副本）
    let handle2 = thread::spawn(|| {
        THREAD_LOCAL_STR.with(|s| {
            s.borrow_mut().push_str("子线程2的内容");
            println!("子线程2 TLS 内容：{}", s.borrow()); // 输出：子线程2的内容
        });
    });

    // 等待子线程完成
    handle1.join().unwrap();
    handle2.join().unwrap();

    // 主线程再次访问，内容还是最初的（不受子线程影响）
    THREAD_LOCAL_STR.with(|s| {
        println!("主线程最终 TLS 内容：{}", s.borrow()); // 输出：主线程的内容
    });
}
```

## 线程间传递消息
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

### 互斥
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

## 原子类型
支持的类型：AtomicBool/AtomicI8/AtomicU32/AtomicIsize/AtomicPtr 等（覆盖基础数值 / 指针类型）；

### Sync 和 Send trait
`Sync`和`Send`用于标记类型的线程安全属性，它们是 Rust 多线程安全的核心抽象（由编译器根据类型结构自动推导，通常不需要手动实现，除非写 unsafe 代码）

* `Send`：类型的所有权可以安全地从一个线程转移到另一个线程（通过 move）。
* `Sync`：类型的不可变引用（&T）可以在多个线程之间安全地共享。

✅ 满足`Send`的类型：
* 所有基础类型（int，float，char，bool，指针）
* 拥有独占所有权的容器：`Box<T>`, `Vec<T>`
* 线程安全的智能指针：`Arc<T>`（要求 `T: Send + Sync`）
* `Mutex<T>`、`RefCell<T>`

❌ 不满足`Send`的类型：
* `Rc<T>`：使用非原子引用计数，跨线程增减引用计数会导致数据竞争
* 裸指针：`*const T`, `*mut T`（无所有权语义，无法静态验证安全性）
* 包含 `!Send` 字段的自定义结构体

✅ 满足`Sync`的类型：
* 基础只读类型：i32, &T
* 原子类型：`AtomicUsize`, `AtomicBool`
* `Mutex<T>`
* 线程安全的智能指针：`Arc<T>`（要求 `T: Send + Sync`）

❌ 不满足`Sync`的类型：
* `Cell<T>`, `RefCell<T>`：提供内部可变性，但无同步机制，即使只有`&T`，也能修改内部状态 → 多线程下不安全
* `Rc<T>`：同上，且引用计数非原子

> **不可变引用不等于不可修改**

#### 自动推导规则
编译器递归检查类型的字段：
* 所有字段都 Send → 类型 Send；
* 所有字段都 Sync → 类型 Sync；

手动实现：仅极特殊场景（如裸指针封装）需 unsafe impl Send for MyType {}（需确保手动实现的安全性）；

#### 一些例子

1. `RefCell<T>` 仅实现了 `Send`（只要 T 实现了 `Send`）
```rust
use std::cell::RefCell;

fn main() {
    let cell = RefCell::new(42);
    
    // ✅ 可以移动到其他线程（Send）
    std::thread::spawn(move || {
        let borrowed = cell.borrow();
        println!("{}", *borrowed);
    });
    
    // ❌ 但不能共享引用（!Sync）
    // let cell_ref = &cell;
    // std::thread::spawn(move || {
    //     cell_ref.borrow();  // 错误！
    // });
}
```

2. `Mutex<T>` 自身实现了 Send 和 Sync，但它只要求 T 实现 Send。因为在 Mutex 的保护期内，只有一个线程能访问 T，所以不需要 T 本身支持并发访问。

3. 如果没有 Send/Sync 会怎样？
假设 Rust 没有 Send/Sync，只提供 Mutex：
```rust
use std::thread;
use std::rc::Rc;
use std::sync::Mutex;

// 用户错误地用 Rc 包装数据
let data = Rc::new(Mutex::new(42));

// 把 Rc<Mutex<i32>> 发送到线程
thread::spawn(move || {
    let val = data.lock().unwrap();
    println!("{}", *val);
});
```
问题：
* Rc 的引用计数是非原子的
* 两个线程同时 clone 或 drop Rc → 数据竞争！
* 即使内部有 Mutex，外层的 Rc 已经不安全了

#### 总结
rust 提供的很多类型实现了`Send`和`Sync`，一般情况下，我们就是使用它们或者它们的组合来创建并发安全的代码。特殊情况下可能需要使用`unsafe`。

并且可以在编译期就阻止了并发安全问题。

## Async、Await
Rust 异步编程同样会使用 `async` 与 `await` 关键字。`async` 函数会返回 `Future` 类型。

### Future
`Future` 是一个稍后可用的值。调用者不必阻塞等待值可用，而是可以继续做其他事情，只有在 Future 完成并且值准备就绪时才切换回来。这和其他语言是类似的。

`Future trait` 定义如下：
```rust
pub trait Future {
    // 任务完成后产出的值类型
    type Output;

    // 核心方法：推进任务执行，状态机流转（Pin 类型在下面会介绍）
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}

// 任务执行结果：要么未完成（Pending），要么完成（Ready）
pub enum Poll<T> {
    Ready(T), // 任务完成，返回结果

    Pending, // 任务还在等待（比如等网络响应），需要后续唤醒
}
```
`poll` 方法的返回值类型是一个叫做 `Poll` 的枚举，它包含两个情况。调用 `poll` 方法会尝试运行该 `future` 直到完成；如果 `future` 完成了，它会返回 `Ready(T)`，其中 `T` 是值的数据类型。如果 `future` 还未完成，则会返回 `Pending`。（`poll`类似 Kotlin 中 Continuation 的 resumeWith 方法）

手动实现 Future 极其繁琐（需要管理状态、保存 Waker、处理 `poll` 逻辑），`async/await` 是 Rust 编译器提供的语法糖，能自动把`async`函数转换成 Future 实现：
```rust
// async fn 本质是返回一个 Future
async fn delay_hello() -> String {
    // await 等待另一个 Future（比如 tokio::time::sleep）
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    "Hello, async!".to_string()
}

// 等价于手动实现 Future（编译器自动生成）
// 注：以下是编译器生成的简化版，实际更复杂
struct DelayHelloFuture {
    state: State, // 保存任务状态（未开始/等待中/完成）
    waker: Option<Waker>, // 保存唤醒器
}

enum State {
    Initial,
    Waiting(Instant),
    Done,
}

impl Future for DelayHelloFuture {
    type Output = String;
    fn poll(&mut self, cx: &mut Context<'_>) -> Poll<Self::Output> {
        match &mut self.state {
            State::Initial => {
                self.state = State::Waiting(Instant::now() + Duration::from_secs(1));
                self.waker = Some(cx.waker().clone());
                Poll::Pending
            }
            State::Waiting(deadline) => {
                if Instant::now() >= *deadline {
                    self.state = State::Done;
                    Poll::Ready("Hello, async!".to_string())
                } else {
                    cx.waker().wake_by_ref();
                    Poll::Pending
                }
            }
            State::Done => unreachable!(),
        }
    }
}
```
不过这个简化代码的`poll`方法需要主动轮询到指定时间点才可以达到完成状态，或者我们也可以通过创建一个线程等待指定时间后调用`waker.wake()`的方式。而实际的 `tokio` 库中提供的 Sleep 异步方法是通过注册 Waker 到底层，通过操作系统的 epoll（Linux情况）等待唤醒。类似 Kotlin 协程在 Android 中的 delay 方法，通过 Handler 本质也是依靠 epoll 机制。

### Pin
`Pin` 的作用是限制 `Future` 不会被 move：
```rust
async fn example() {
    let mut buf = [0u8; 1024];
    let reader = &mut buf[..]; // ← reader 指向 buf
    some_async_read(reader).await; // ← 挂起时，reader 必须仍然有效！
}

// 生成的 Future 类似如下代码：
struct ExampleFuture {
    buf: [u8; 1024],
    reader: *mut u8,   // ← 指向 buf 的指针！
}
```
⚠️ 如果这个 Future 被 移动（move）了：
```rust
let f1 = ExampleFuture { ... };
let f2 = f1; // ← move！整个 struct 被复制到新内存地址
// buf 的地址跟随 Future 变了，但 reader 还是指向旧地址，产生了内存安全漏洞。
```
Rust 无法在类型系统中直接表达“这个 struct 不能被 move”，但可以换一种思路：“如果你把这个值放在 Pin 里，就保证它不会再被 move。”

Pin 提供了`project()`方法，用于将 `Pin<&mut Self>` 解包为 `&mut Self`，从而可以访问到 `Self` 中的字段。

### 异步函数状态机
编译器会将 `async fn` 转换为状态机（实现了 `Future` trait 的结构体）
```rust
async fn fetch_data() -> Result<String, Error> {
    let data = read_from_db().await?;  // await 点
    process_data(data).await
}

// 编译器将 async fn 转换为类似这样的代码，每个 await 点对应一个状态
enum GeneratedFuture {
    Start,
    AwaitingReadFromDb(ReadFromDbFuture),
    AwaitingProcessData(ProcessDataFuture),
    Done,
}

impl Future for GeneratedFuture {
    fn poll(...) -> Poll<Result<String, Error>> {
        // 自动生成的状态机逻辑代码
    }
}
```
生成的`Future`实现类的`poll`方法中会生成对应的状态机代码，这由编译器自动完成，但是谁来调用 `poll` 方法呢？`async fn` 只是构造了一个 `Future`，它本身不会执行任何异步操作。要让 `.await` 生效，让异步任务实际运行，必须有一个 runtime 来“驱动”这个 Future。rust 没有内置异步运行时库，而是由第三方社区实现，其中 `Tokio` 是最常用的异步运行时库。

每当执行一个 future 时遇到 await 点，控制权就会让回给运行时去执行其他任务。当 future 等待的事件发生后，运行时会找到等待该事件的 future 并再次尝试轮询它，以便 future 可以继续执行。

### Waker
`Future` 的 `poll` 返回 Pending 后，需要在实际完成后再次调用 `poll` 从而完成任务。而 Waker 就是用于再次调用 `poll`。

```rust
pub struct Waker {
    // ...
}

pub struct Context<'a> {
    waker: &'a Waker,
    // ...
}

impl Waker {
    pub fn wake(self) {
        ...
    }
}
```
`Future::poll` 的参数 `&mut Context<'_>` 是 “任务上下文”，核心作用是传递唤醒信号，里面最关键的是 Waker 类型。Waker 的 `wake()/wake_by_ref()` 方法用于告诉运行时 “这个 Future 可以继续执行了，请再次调用它的 poll 方法”。

所以在 Tokio 的内部实现中，当一个 Future 被注册到事件源（如定时器、I/O）后，Tokio 内部会保存该 Future 对应的 Waker，事件源会在事件发生时调用 Waker 的 `wake()` 方法，从而通知运行时该 Future 可以继续执行。

## Tokio 使用
Tokio 是 rust 最流行的异步运行时库，它提供了多线程执行异步代码和各种API的异步版本。并且还有相关库 `tokio-util`、`tokio-stream` 等。

在使用tokio之前，应当先理解tokio的核心概念：`runtime` 和 `task`。
* `runtime`：运行时是运行异步代码的主体，它负责创建和运行任务，是所有异步任务的运行环境。
* `task`：任务是运行在 Tokio 运行时中的异步代码，每个任务都对应一个 Future。

### 创建 Tokio Runtime
```rust
// 使用 #[tokio::main] 宏
#[tokio::main]
async fn main() {
    println!("hello");
}

// 会转换为 -->
fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        println!("hello");
    })
}

// 也可以自己写（new方法内部也使用了Builder）：
let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .worker_threads(8)  // 8个工作线程
        .enable_io()        // 可在runtime中使用异步IO
        .enable_time()      // 可在runtime中使用异步计时器(timer)
        .build()            // 创建runtime
        .unwrap();
```
tokio提供了两种工作模式的runtime：

1.单一线程的runtime(single thread runtime，也称为`current thread runtime`)
2.多线程(线程池)的runtime(`multi thread runtime`)


```rust
// 单一线程的main runtime：
#[tokio::main(flavor = "current_thread")]
async main() {}

// 创建单一线程的runtime
let rt = tokio::runtime::Builder::new_current_thread().build().unwrap();
```

> Runtime 可以创建多个，比如需要不同配置的runtime

> `Runtime` 实现了`Send`和`Sync`这两个Trait，因此可以将`Runtime`放在Arc里，然后跨线程使用同一个runtime。

### 使用 Runtime

1. **block_on**
用于阻塞运行 Future：
```rust
use tokio::runtime::Runtime;
use chrono::Local;

fn main() {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        println!("before sleep: {}", Local::now().format("%F %T.%3f"));
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
        println!("after sleep: {}", Local::now().format("%F %T.%3f"));
    });
}
```
`block_on` 要求一个`Future`作为参数，可以像上面一样直接使用一个`async {}`来定义一个Future。block_on 会阻塞当前线程(例如阻塞上面的main函数所在的主线程)，直到其指定的**异步任务树(可能有子任务)**全部完成。

2. **spawn**
启动新任务
```rust
let rt = Runtime::new().unwrap();

// spawn：非阻塞，返回 JoinHandle
let handle = rt.spawn(async {
    println!("任务开始");
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    println!("任务结束");
    42
});

// 可以继续执行其他代码
println!("spawn 后立即执行的代码");

let task_result = handle.await.unwrap(); // 得到结果，不过需要在异步函数中调用 .await，这里省略
```
`spawn`方法会返回一个`JoinHandle`，它实现了 `Future`，可以用于获取任务执行结果。

3. **spawn_blocking**
用于在异步运行时中执行阻塞的、CPU密集型的或长时间运行的同步代码。因为 Tokio 内部维护一个专用的阻塞线程池，`spawn_blocking`方法会将阻塞代码提交到这个线程池，而不会阻塞 Worker 线程池。
```rust
#[tokio::main]
async fn main() {
    // ✅ 正确：将阻塞操作放到专用线程
    let blocking_handle = tokio::task::spawn_blocking(|| {
        std::thread::sleep(std::time::Duration::from_secs(5));  // 在专用线程中阻塞
        "阻塞操作完成"
    });
    
    // ✅ 其他异步任务可以立即执行
    let async_handle = tokio::spawn(async {
        println!("异步任务立即执行");
        "异步操作完成"
    });
    
    // 并发执行，互不干扰
    let (blocking_result, async_result) = 
        tokio::join!(blocking_handle, async_handle);
    
    println!("阻塞结果: {:?}", blocking_result.unwrap());
    println!("异步结果: {:?}", async_result.unwrap());
}
```

4. **enter**
临时将当前线程“绑定”到指定的 Tokio 运行时上下文（通过 Thread Local 存储），将当前线程“注入”到某个 Tokio 运行时的上下文中，使得后续可以直接使用 `tokio::spawn`、`tokio::time::sleep` 等全局 API，而无需显式持有 `Runtime` 的引用。

`enter()` 让你可以自由选择编程风格：比如库作者写 `tokio::spawn`（不绑定具体 runtime 实例），调用方通过 enter() 提供上下文

6. **shutdown_timeout** 和 **shutdown_background**
`shutdown_timeout`会关闭runtime，等待所有任务完成，但最多等待 duration，如果超时，强制终止未完成的任务。

```rust
let rt = Runtime::new().unwrap();

rt.spawn(async {
    tokio::time::sleep(Duration::from_secs(3)).await;
    println!("Long task done");
});

// 关闭运行时
println!("Shutting down with 1s timeout...");
rt.shutdown_timeout(Duration::from_secs(1)); // ← 只等 1 秒

println!("Runtime shut down");

thread::sleep(Duration::from_secs(5)); // 主线程等待 5 秒，验证 runtime 任务是否执行
```

如果你不想等待任务完成，只想尽快释放 Runtime 的资源（比如程序即将退出），可以用 `shutdown_background`

> 这两个 shutdown 方法的具体实现，比如当前正在执行的任务会被怎样处理，如何停止，官方文档和很多资料都没有说清楚，需要之后查看源码

### 并发管理API

#### 1. join
使用`tokio::join!()`和`tokio::try_join!()`可以等待多个并发任务完成
```rust
let (r1, r2) = tokio::join!(handle1, handle2);

let (r1, r2) = tokio::try_join!(handle1, handle2)?; // 任一 Err 则提前返回

// futures::future::join_all（来自 futures crate）
use futures::future::join_all;

let handles: Vec<_> = tasks.into_iter().map(tokio::spawn).collect();
let results = join_all(handles).await; // 返回 Vec<Result<T, E>>
```

`try_join!` 会在任意一个 Future 返回 Err 时提前返回，其他正在执行的任务还会继续执行

#### 2. JoinSet
`JoinSet`适合动态数量的任务
```rust
use tokio::task::JoinSet;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let mut set = JoinSet::new();
    let parent_data = std::sync::Arc::new("join set demo");

    // 1. 批量 spawn 子任务（结构化：子任务归属 JoinSet）
    for i in 0..3 {
        let data = parent_data.clone();
        set.spawn(async move {
            sleep(Duration::from_millis(i * 100)).await;
            println!("task {}: {}", i, data);
            i
        });
    }

    // 2. 等待所有子任务完成（结构化核心：父等待子）
    let mut results = Vec::new();
    while let Some(res) = set.join_next().await {
        results.push(res.unwrap());
    }
    println!("all tasks completed: {:?}", results); // [0,1,2]
}
```

`JoinSet`的常用方法：
* `abort_all`：取消全部未完成的任务，任务被取消后，后续调用 `join_next()`/`join_all()` 会返回 `Err(JoinError::Cancelled)`（任务被取消）或 Ok(结果)（任务在取消前已完成）。调用后立即向所有任务发送取消信号，任务会在下次执行 `await` 点（或取消安全的代码点）终止
* `shutdown`：首先对 JoinSet 中所有未完成的任务调用 abort()（同 abort_all）；然后阻塞等待所有任务执行完毕（包括完成、取消、panic）；调用后 JoinSet 变为空，后续无法再 spawn 新任务（调用 spawn 会 panic）
* `detach_all`：对 `JoinSet` 中所有未完成的任务调用 `detach()` 方法，使任务脱离 `JoinSet` 的管控；脱离后的任务会在后台继续执行，JoinSet 不再跟踪其状态，也无法获取其结果或取消其执行；调用后 JoinSet 变为空，可继续 spawn 新任务。

#### 3. JoinHandle 和 JoinError
```rust
let joinHandle = tokio::spawn(async { ... });

joinHandle.is_finished(); // 是否完成
joinHandle.abort(); // 提前取消，返回取消类型的 JoinError 
joinHandle.await.unwrap_err().is_cancelled(); // 获取错误结果，并可以判断是否被取消
joinHandle.await.unwrap_err().is_panic(); // 获取错误结果，并判断是否是 panic
```

`joinHandle.abort()`就是用来取消任务的API，它的内部实现方式是：
1. 标记取消：通过原子布尔值设置任务的取消标记为 true；
2. 强制唤醒：调用任务的 Waker，将任务重新加入运行时的就绪队列，确保任务被调度执行；
3. 协作式退出：取消检查发生在每个挂起点恢复时（即每次 poll 调用时），若为 true 则主动退出，完成取消。如果是比如长时间的循环任务则需要主动判断状态。（Tokio中的 `sleep`、`read` 等都内置了取消检查）

#### select!
同一 `select!` 块中，只有第一个完成的异步操作会执行对应分支，其余future对应的分支不会被执行。每个分支都要求是一个**异步表达式**。
```rust
// 语法模板
tokio::select! {
    // [可选] 开启 biased 模式
    biased;

    // 标准分支（带 if 守卫）
    pattern = future_expr if condition => {
        // handler
    },

    // 忽略结果
    _ = another_future => {
        // do something
    },

    // ...

    // [可选] else 分支（仅当所有 if 条件为 false 时执行）
    else => {
        // fallback logic
    }
}
```

一个例子：
```rust
#[tokio::main]
async fn main() {
    // 启动一个后台任务（不受 select! 取消影响）
    let handle = tokio::spawn(async {
        sleep(Duration::from_secs(2)).await;
        println!("background task completed");
    });

    // select! 仅取消对 handle 的 await，任务本身继续运行
    let result = tokio::select! {
        r1 = handle => {
            println!("await handle");
            "流程1"
        },
        // 在分支的代码中用不到返回值，可以使用 `_` 下划线，这样就不用命名了
        _ = sleep(Duration::from_secs(1)) => {
            println!("await cancelled");
            "流程2"
        },
    };
    println!("select! 返回: {}", result);
    sleep(Duration::from_secs(5)).await; // 等待后台任务完成
}

// 打印结果
// await cancelled
// select! 返回: 流程2
// background task completed
```
`select!` 只会执行先完成的future对应的分支代码，其他future不会再调用`poll`，对应的分支代码也不会被执行，但由于这里的任务使用了`tokio::spawn`，即使`select!`不会再调用`tokio::spawn`返回的future的`poll`方法，但`tokio::spawn`传递的异步函数对应的future仍然会被`tokio`运行时调用`poll`和执行。如果想停止这个任务则需要主动调用 `JoinHandle::abort()`

而下面这个例子，直接使用异步函数对应的future，则可以看出`select!`的取消效果：
```rust
let result = tokio::select! {
    _ = async {
        println!("background task start");
        sleep(Duration::from_secs(2)).await;
        println!("background task completed");
    } => {
        println!("await handle");
        "流程1"
    },
    _ = sleep(Duration::from_secs(1)) => {
        println!("await sleep 1 second");
        "流程2"
    },
};

println!("select! 返回: {}", result);
sleep(Duration::from_secs(5)).await; // 等待后台任务完

// 打印结果
// background task start
// await sleep 1 second
// select! 返回: 流程2
```

`select!` 本身不会主动将异步表达式放入线程池执行，也不会调用 `tokio::spawn` —— 它只是一个 “异步等待调度器”，异步表达式的执行位置/方式，完全由其自身的 Future 实现和 Tokio 运行时的调度规则决定，通俗的说就是只管`poll`，不管内部实现。例如：
* `select! 内使用普通异步块（async { ... }）`：与 select! 所在的任务同线程 / 同执行上下文
* `select! 内使用 tokio::spawn 返回的任务句柄`：线程池（Tokio 默认的多线程运行时）


`select!` 还支持 `if`、`else`：
```rust
// 使用 if 条件预筛选
let condition = true;

tokio::select! {
    res = async_operation1(), if condition => {
        println!("条件分支被选中");
    }
    _ = async_operation2() => {
        println!("无条件分支");
    }
}

// 使用 else 分支
let maybe_future: Option<impl Future> = Some(async { 42 });

tokio::select! {
    res = maybe_future, if maybe_future.is_some() => {
        println!("有future被选中: {}", res)
    }
    else => {
        println!("没有future可等待")
    }
}
```
> `select!`必须保证至少有一个分支被执行，所以都有可能不执行的情况就必须加上`else`

**在循环中使用**，主要用于构建事件驱动的异步服务或后台任务，其核心思想是：在一个无限（或条件控制）循环中，持续监听多个异步事件源，并对最先发生的事件做出响应。
```rust
use tokio::net::TcpListener;
use tokio::signal::ctrl_c;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // 启动 TCP 监听器
    let listener = TcpListener::bind("127.0.0.1:8080").await.unwrap();
    println!("server running on 8080, press Ctrl+C to exit");

    loop {
        tokio::select! {
            // 事件1：监听新的客户端连接
            Ok((stream, addr)) = listener.accept() => {
                println!("new client: {}", addr);
                // 异步处理客户端请求（不阻塞主线程）
                tokio::spawn(async move {
                    // 简化处理：仅打印连接信息
                    sleep(Duration::from_secs(1)).await;
                    println!("client {} disconnected", addr);
                });
            },
            // 事件2：监听 Ctrl+C 中断信号
            _ = ctrl_c() => {
                println!("received Ctrl+C, shutting down");
                break; // 退出循环，终止服务器
            },
            // 事件3：定时打印服务器状态（可选）
            _ = sleep(Duration::from_secs(5)) => {
                println!("server alive, current time: {:?}", std::time::Instant::now());
            }
        }
    }
}
```

`biased` 用于控制选择策略：
```rust
#[tokio::main]
async fn main() {
    // 默认：公平选择，随机轮询
    tokio::select! {
        _ = async { print!("A") } => {},
        _ = async { print!("B") } => {},
        _ = async { print!("C") } => {},
    }
    // 输出可能是 A、B、C 中的任意一个
    
    // 使用 biased：按代码顺序选择
    tokio::select! {
        biased;  // 添加 biased 关键字
        
        _ = async { print!("A") } => {},
        _ = async { print!("B") } => {},
        _ = async { print!("C") } => {},
    }
    // 总是输出 A，因为 biased 按顺序检查
}
```

#### CancellationToken
调用`JoinHandle::abort()`之后，可以在`Future`的`poll`方法实现中检测取消，但无法被动监听取消。我们只能间接通过`tokio::task::yield_now()`或者其他tokio的内置异步函数（例如sleep）来主动检测取消。但不适合纯 CPU 循环的情况，对此Tokio在`tokio-util`中提供了`CancellationToken`，可以用来监听取消。

`CancellationToken`提供了一种广播式的取消机制：一个令牌可以被多个任务共享，取消时所有任务都能收到通知。

```rust
async fn worker_with_select(token: CancellationToken) {
    let mut interval = tokio::time::interval(Duration::from_secs(1));
    
    loop {
        tokio::select! {
            // 取消信号有最高优先级
            _ = token.cancelled() => {
                println!("收到取消，退出");
                break;
            }
            // 定期工作
            _ = interval.tick() => {
                println!("执行定期工作");
                do_periodic_work().await;
            }
            // 处理其他事件
            Some(event) = receive_event() => {
                handle_event(event).await;
            }
        }
    }
    
    graceful_shutdown().await;
}
```
这个例子，借助`select!`来监听`token.cancelled()`返回的取消事件future。

`CancellationToken`的常用方法：
* `is_cancelled()`：用于主动检测取消，比如在循环中或者一些检查点使用
* `cancelled()`：返回一个future，用于监听取消
* `run_until_cancelled(future)`：会运行一个 Future，直到它完成或者关联的 CancellationToken 被触发（取消）。它是一个便捷工具函数，用于将“可取消的执行”封装起来，避免手动写 `tokio::select!`。

> `cancelled()` 和 `run_until_cancelled()` 都有一个带`owned`的版本`cancelled_owned()` 和 `run_until_cancelled_owned()`，前者基于引用工作，不获取 CancellationToken 的所有权，令牌仍可在当前作用域继续使用；后者基于所有权工作，会夺取 CancellationToken 的所有权，调用后原变量不可再使用。

`run_until_cancelled` 可以运行一个异步任务直到取消信号到达。这特别适合需要持续运行直到被显式停止的服务或后台任务。可以作为`select!`在个别场景的替代方式。
```rust
use tokio_util::sync::CancellationToken;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // 1. 创建取消令牌
    let token = CancellationToken::new();
    
    // 2. 使用 run_until_cancelled 运行任务
    let task = tokio::spawn({
        let token = token.clone();
        async move {
            // 这个任务会一直运行，直到 token 被取消
            token.run_until_cancelled(async {
                // 这是你要持续运行的逻辑
                let mut count = 0;
                loop {
                    println!("任务运行中... 计数: {}", count);
                    count += 1;
                    
                    // 注意：这里面的代码应该包含 await 点
                    // 否则会 busy loop！
                    sleep(Duration::from_secs(1)).await;
                }
            }).await;
            
            // 取消后执行清理
            println!("任务收到取消信号，开始清理...");
            cleanup().await;
            println!("清理完成");
        }
    });
    
    // 3. 让任务运行一会儿
    println!("让后台任务运行5秒...");
    sleep(Duration::from_secs(5)).await;
    
    // 4. 取消任务
    println!("取消任务");
    token.cancel();
    
    // 5. 等待任务结束
    task.await.unwrap();
    println!("主程序结束");
}

async fn cleanup() {
    sleep(Duration::from_millis(500)).await;
    println!("清理工作完成");
}
```
如果 `future` 先完成，`run_until_cancelled`方法会返回 Some(output)，如果 token 先被取消，则返回 None


`child_token()` 方法是 `CancellationToken` 中用于创建父子令牌关系的核心功能。它创建的子令牌会继承父令牌的取消状态，并且可以有自己的独立取消逻辑。
* 父 token 被取消 → 所有子 token 自动取消
* 子 token 被取消 → 不影响父 token 和兄弟 token

```rust
use tokio_util::sync::CancellationToken;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // 1. 创建父令牌
    let parent = CancellationToken::new();
    
    // 2. 创建子令牌
    let child = parent.child_token();
    
    // 3. 启动两个任务
    let parent_task = tokio::spawn({
        let parent = parent.clone();
        async move {
            println!("父任务: 等待取消");
            parent.cancelled().await;
            println!("父任务: 已取消");
        }
    });
    
    let child_task = tokio::spawn({
        let child = child.clone();
        async move {
            println!("子任务: 等待取消");
            child.cancelled().await;
            println!("子任务: 已取消");
        }
    });
    
    // 4. 只取消父令牌
    sleep(Duration::from_secs(1)).await;
    println!("取消父令牌...");
    parent.cancel();
    
    // 5. 两个任务都会完成！
    tokio::join!(parent_task, child_task);
    println!("两个任务都完成了");
}
```

### Stream
`tokio-stream`是 Tokio 提供的异步流处理库

基本使用：
```rust
use tokio_stream::{self as stream, StreamExt};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    // 1. 创建 Stream（最简单的方式）
    let mut stream = stream::iter(vec![1, 2, 3, 4, 5]);
    
    // 2. 消费 Stream
    while let Some(value) = stream.next().await {
        println!("收到值: {}", value);
    }
}
```

stream 提供了很多**流式操作符**，例如：
```rust
use tokio_stream::{self as stream, StreamExt};

#[tokio::main]
async fn main() {
    // 1. map - 转换每个元素
    let mapped: Vec<_> = stream::iter(1..=5)
        .map(|x| x * 2)
        .collect()
        .await;
    println!("map 后: {:?}", mapped);  // [2, 4, 6, 8, 10]

    // 2. filter - 过滤元素
    let filtered: Vec<_> = stream::iter(1..=10)
        .filter(|&x| { x % 2 == 0 })
        .collect()
        .await;
    println!("filter 后: {:?}", filtered);  // [2, 4, 6, 8, 10]

    // 3. take - 取前 n 个元素
    let taken: Vec<_> = stream::iter(1..)
        .take(3)
        .collect()
        .await;
    println!("take 3: {:?}", taken);  // [1, 2, 3]
}
```

* `ReceiverStream`可以把 tokio 中的 channel receiver 包装为 stream
* `BroadcastStream`结合`broadcast::channel`、`mpsc`可以实现热流

stream本质上实现了`Stream trait`，我们也可以手动实现：
```rust
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio_stream::{Stream, StreamExt};

struct CountdownStream {
    count: i32,
}

impl Stream for CountdownStream {
    type Item = i32;

    fn poll_next(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        if self.count > 0 {
            let value = self.count;
            self.count -= 1;
            Poll::Ready(Some(value))
        } else {
            Poll::Ready(None)
        }
    }
}

#[tokio::main]
async fn main() {
    let mut stream = CountdownStream { count: 5 };
    while let Some(value) = stream.next().await {
        println!("倒计时: {}", value);
    }
}
```

### 回调转换为异步函数
`tokio::sync::oneshot` 是专为此类“一次通信”设计的通道，完美匹配“回调 转为 异步返回值”。
```rust
type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

fn do_something_async_fallible(callback: impl FnOnce(Result<i32>) + Send + 'static) {
    std::thread::spawn(move || {
        std::thread::sleep(std::time::Duration::from_millis(500));
        if rand::random() {
            callback(Ok(42));
        } else {
            callback(Err("Something went wrong".into()));
        }
    });
}

async fn do_something_safe() -> Result<i32> {
    let (tx, rx) = oneshot::channel();

    do_something_async_fallible(move |result| {
        let _ = tx.send(result); // 忽略取消导致的 send 失败
    });

    rx.await.map_err(|_| "Callback dropped without result".into())
}
```


`Notify`也可以，但它只通知事件发生，不传递数据，如果要传递数据，就需要额外共享存储。没有`oneshot`方便
```rust
use tokio::sync::Notify;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::thread;

async fn delay(dur: Duration) {
    let when = Instant::now() + dur;
    let notify = Arc::new(Notify::new());
    let notify_clone = notify.clone();

    thread::spawn(move || {
        let now = Instant::now();

        if now < when {
            thread::sleep(when - now);
        }

        notify_clone.notify_one();
    });


    notify.notified().await;
}
```

### 结构化并发
tokio要实现结构化并发，需要结合`JoinSet`、`select!`和 `CancellationToken`等工具手动实现，不像Kotlin、Swift的协程是自带结构化并发。

### Task
* `Future` 是一个惰性的异步计算描述（如 `async { ... }`），它本身不执行，也不占用调度资源。
* `Task` 是 runtime 中被调度执行的 `Future` 实例，相当于“绿色线程”或“协程”。
* 通过 `tokio::spawn(future)`，可以将一个 `Future` 提交给调度器，从而创建一个独立的 `task`，实现并发执行。
* 如果不 `spawn` 而直接 `.await`，则 Future 会在当前 `task` 中顺序执行，不会产生新 `task`。

### task 通信和同步
tokio的异步任务之间主要采用消息传递(message passing)的通信方式，即某个异步任务负责发消息，另一个异步任务收消息。这种通信方式的最大优点是避免并发任务之间的数据共享，消灭数据竞争，使得代码更加安全，更加容易维护。

消息传递通常使用通道(channel)来进行通信

* `oneshot通道`: 一对一发送的一次性通道
* `mpsc channel`: 多对一发送，多个 Sender，一个 Receiver
* `broadcast channel`: 一对多发送
* `watch通道`: 一对多发送，总是持有最新值，适合“状态快照”场景

> 也可以使用`Mutex/RwLock`来共享内存

## Tokio 实现原理
总览：

1. Tokio Runtime 驱动双引擎：
* IO Driver：基于系统机制（如 epoll/kqueue/IOCP）处理异步 I/O。
* Timer Driver：支持 tokio::time::sleep() 等定时操作。

> ✅ 二者共同构成事件循环（Reactor + Timer），驱动非阻塞任务。

2. 调度模型
* Scheduler + Worker Threads + Work-Stealing：
  * 多工作线程，每线程私有任务队列；
  * 空闲时从其他队列“偷取”任务，实现负载均衡；
  * 协作式调度：任务通过 .await 主动让出 CPU（不抢占）；
  * 底层由 OS 抢占式调度兜底，保证系统安全

> tokio的作者，非常友好地提供了一篇他实现tokio调度器的思路，里面详细介绍了调度器的基本知识和tokio调度器的调度策略，参考 https://tokio.rs/blog/2019-10-scheduler

3. 线程模型
* Worker Thread：执行异步任务（I/O 密集型），遇 await 即交还控制权，高效复用
* Blocking Thread：执行阻塞/CPU 密集型任务，通过 spawn_blocking() 按需创建，避免阻塞 worker

> 对于面向大众使用的操作系统(如Linux)通常采用抢占式调度策略来保证系统安全，避免恶意程序霸占CPU。而对于语言层面来说，通常采用协作式调度策略，这样既有底层OS的抢占式保底，又有协作式的高效。tokio的调度策略是协作式调度策略。

4. 异步函数与 Future
* 应用层：用 async fn 编写，编译为状态机（无需手动实现 Future）。
* 底层原语（如 Sleep, Receiver）：手动实现 Future::poll，故函数返回 impl Future 但不加 async。

> tokio 提供的异步函数返回Future，并且没有标记 async，因为它自己实现了 Future 的 poll 状态机，不需要标记 async 再生成状态机

**Tokio 基于 rust 的 future、waker 等机制的异步框架实现原理可以在官方文档查看**：https://tokio.rs/tokio/tutorial/async，下面根据这些原理介绍，具体分析。

### Waker 创建、与 Future 关联及触发 poll 方法的完整逻辑
分析 Waker 的创建机制、与 Future 的关联方式，以及调用 Waker 后触发 Future::poll 的全链路，结合 Tokio/MiniTokio（官方文档极简运行时）的核心逻辑，拆解 Rust 异步体系中这一关键闭环。

#### 一、核心前提：角色定位
- **Waker**：运行时生成的“唤醒信号器”，不直接持有 Future，仅绑定「Task（运行时调度的最小单元）」，核心作用是通知运行时“某个 Task 可重新执行”。
- **Future**：封装异步任务逻辑的核心抽象，通过 `poll` 方法推进执行，执行到等待点时需保存 Waker 以便后续唤醒。
- **运行时（Executor，如 Tokio/MiniTokio）**：统筹 Waker 创建、Task 调度、Future::poll 调用的核心，是整个异步体系的“调度中心”。
- **Context**：Waker 与 Future 之间的“通信桥梁”，封装 Waker 并通过 `Future::poll` 传递给 Future。

#### 二、第一步：Waker 的创建（运行时主导）
Waker 由运行时为每个 Task 专属生成，而非 Future 自行创建，核心依赖 `futures::task::ArcWake` trait 实现：

##### 1. 基础准备：Task 封装 Future
运行时通过 `spawn` 接收用户提交的 Future 后，会将其包装为 `Task` 结构体（运行时调度的最小单元），示例（MiniTokio 简化版）：
```rust
use std::sync::Arc;
use futures::task::{ArcWake, waker};

// 运行时的 Task 结构体：封装 Future + 就绪队列发送器
struct Task {
    future: std::sync::Mutex<Box<dyn std::future::Future<Output = ()> + Send>>,
    sender: std::sync::mpsc::Sender<Arc<Task>>, // 就绪队列发送器
}
```

##### 2. 实现 ArcWake trait：定义唤醒逻辑
运行时为 `Task` 实现 `ArcWake` trait，该 trait 是创建 Waker 的核心——要求实现 `wake_by_ref` 方法，逻辑是“将当前 Task 重新加入运行时的就绪队列”：
```rust
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        // 核心：把 Task 发送到就绪队列，等待运行时调度
        let _ = arc_self.sender.send(arc_self.clone());
    }
}
```

##### 3. 生成 Waker 实例
基于实现了 `ArcWake` 的 `Arc<Task>`，调用 `waker()` 方法即可生成 Waker 实例（轻量级句柄，绑定当前 Task）：
```rust
// 运行时为 Task 创建 Waker
let task = Arc::new(Task { /* 初始化 */ });
let waker = waker(task.clone()); // 核心：生成 Waker
```

#### 三、第二步：Waker 与 Future 的关联（Context 作为桥梁）
Waker 生成后，通过 `Context` 传递给 Future，由 Future 主动保存完成关联，全程分 3 步：

##### 1. 封装 Waker 到 Context
运行时将生成的 Waker 封装进 `Context` 结构体（Waker 的唯一传递载体）：
```rust
use std::task::Context;

// 封装 Waker 到 Context
let mut cx = Context::from_waker(&waker);
```

##### 2. 调用 Future::poll，传递 Context
运行时调用 Future 的 `poll` 方法，将包含 Waker 的 `Context` 作为参数传入——这是 Waker 到达 Future 的关键：
```rust
impl Task {
    fn poll(self: Arc<Self>) {
        let waker = waker(self.clone());
        let mut cx = Context::from_waker(&waker);
        // 取出 Task 中的 Future，调用 poll 并传递 Context
        let mut future = self.future.lock().unwrap();
        let _ = future.as_mut().poll(&mut cx);
    }
}
```

##### 3. Future 保存 Waker，完成关联
Future 执行到“等待点”（如 `Delay` 未到时间、IO 未就绪）时，需从 `Context` 中取出 Waker 并保存，以便后续资源就绪时唤醒：
```rust
use std::time::Instant;
use std::task::{Poll, Waker};
use std::sync::{Arc, Mutex};

// 示例：自定义 Delay Future
struct Delay {
    when: Instant,
    waker: Option<Arc<Mutex<Waker>>>, // 保存 Waker 的字段
}

impl std::future::Future for Delay {
    type Output = ();

    fn poll(mut self: std::pin::Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // 1. 检查资源是否就绪（时间到则完成）
        if Instant::now() >= self.when {
            return Poll::Ready(());
        }

        // 2. 保存 Waker（核心：完成 Future 与 Waker 的关联）
        if let Some(waker) = &self.waker {
            let mut inner_waker = waker.lock().unwrap();
            // 兼容 Future 迁移场景：更新为最新 Waker
            if !inner_waker.will_wake(cx.waker()) {
                *inner_waker = cx.waker().clone();
            }
        } else {
            // 首次 poll：初始化并保存 Waker
            let waker = Arc::new(Mutex::new(cx.waker().clone()));
            self.waker = Some(waker.clone());
            
            // 启动定时器：到期后调用 Waker::wake()
            std::thread::spawn(move || {
                std::thread::sleep(self.when.duration_since(Instant::now()));
                let waker = waker.lock().unwrap().clone();
                waker.wake(); // 资源就绪后唤醒
            });
        }

        // 3. 返回 Pending，任务暂停
        Poll::Pending
    }
}
```

###### 关联关键细节
- 关联是“Future 主动保存”：运行时仅负责传递 Waker，Future 若未保存则后续无法被唤醒；
- 支持 Waker 更新：Future 可能迁移到其他 Task（如 Tokio 中 Worker 线程窃取任务），需每次 `poll` 检查 Waker 有效性，不匹配则更新。

#### 四、第三步：Waker 触发 Future::poll 的完整链路
调用 Waker 的 `wake()` 方法后，不会直接触发 `poll`，而是通过“运行时调度 Task”的间接链路完成，核心分 5 步：

##### 1. 资源就绪，调用 Waker::wake()
当 Future 等待的资源就绪（如 `Delay` 时间到、IO 就绪），执行之前保存的 Waker 的 `wake()` 方法：
```rust
// 资源就绪逻辑（如定时器到期）
fn on_timer_expire(saved_waker: Waker) {
    saved_waker.wake(); // 发送唤醒信号
}
```

##### 2. Waker 触发 ArcWake::wake_by_ref
`wake()` 方法会触发 `ArcWake::wake_by_ref`（Waker 绑定的 Task 实现的逻辑），核心动作是“将 Task 加入运行时就绪队列”：
```rust
// 对应前文 ArcWake 实现：Task 入队
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        arc_self.sender.send(arc_self.clone()).unwrap(); // Task 入队
    }
}
```

##### 3. 运行时消费就绪队列
运行时启动 Worker 线程（单/多线程），循环监听就绪队列，一旦有 Task 入队则取出：
```rust
// MiniTokio 运行时核心循环
impl MiniTokio {
    fn run(&self) {
        while let Ok(task) = self.receiver.recv() { // 取出就绪队列中的 Task
            task.poll(); // 执行 Task 的 poll 方法
        }
    }
}
```

##### 4. Task 重新创建 Waker/Context
Worker 线程取出 Task 后，会重新创建 Waker 和 Context（确保 Waker 是最新的，适配 Task 迁移场景）：
```rust
impl Task {
    fn poll(self: Arc<Self>) {
        // 重新创建 Waker（关键：适配 Task 迁移）
        let waker = waker(self.clone());
        let mut cx = Context::from_waker(&waker);
        
        // 取出 Future，准备调用 poll
        let mut future = self.future.lock().unwrap();
        let _ = future.as_mut().poll(&mut cx);
    }
}
```

##### 5. 最终触发 Future::poll
Task 调用 `future.poll(&mut cx)`，Future 再次执行：
- 若资源已就绪：返回 `Poll::Ready`，任务完成；
- 若资源仍未就绪：再次保存最新 Waker，等待下一次唤醒。

#### 五、核心总结（全链路闭环）
##### 1. 核心流程串讲
运行时 spawn Future → 包装为 Task → 为 Task 实现 ArcWake 并创建 Waker → Waker 封装进 Context → 调用 Future::poll 传递 Context → Future 保存 Waker → 资源就绪调用 Waker::wake → Task 入队就绪队列 → 运行时 Worker 取出 Task → Task 重新创建 Waker/Context → 调用 Future::poll。

##### 2. 关键记忆点
- **Waker 创建**：运行时基于 ArcWake 为 Task 生成，绑定 Task 而非直接绑定 Future；
- **关联方式**：Context 作为桥梁，Future 主动保存 Context 中的 Waker；
- **触发 poll**：Waker 仅负责将 Task 入队，运行时调度 Task 后，由 Task 重新创建 Waker/Context 并调用 Future::poll；
- **核心解耦**：Waker 不感知 Future，只关联 Task；运行时只调度 Task，不直接操作 Future。

##### 3. 可视化流程图
```
┌─────────────┐    spawn   ┌─────────────┐    实现 ArcWake    ┌─────────────┐
│ 用户 Future │ ─────────→  │ Task        │ ───────────────→  │ Waker       │
└─────────────┘            └─────────────┘                   └─────────────┘
                                          │ 封装进 Context
                                          ▼
┌─────────────┐ 通过 poll 传递 ┌─────────────┐    保存 Waker   ┌─────────────┐
│ 运行时       │ ←──────────── │ Context     │ ─────────────→ │ Future      │
└─────────────┘               └─────────────┘                └─────────────┘
       │                                                          │
       │ 资源就绪调用 wake()                                        │ 返回 Pending
       ▼                                                          ▼
┌─────────────┐    Task 入队   ┌─────────────┐    Worker 取出  ┌─────────────┐
│ Waker::wake │ ───────────→  │ 就绪队列      │ ─────────────→ │ Task::poll  │
└─────────────┘               └─────────────┘                 └─────────────┘
                                                                 │
                                                                 ▼
                                                           ┌─────────────┐
                                                           │ Future::poll│
                                                           └─────────────┘
```

### 以Sleep为例，查看源码
运行时（如 tokio）会定义自己的任务结构体，并实现 Wake：
```rust
// tokio 内部简化示意
struct Task {
    id: TaskId,
    scheduler: Weak<Scheduler>,
}

impl Wake for Task {
    fn wake(self: Arc<Self>) {
        if let Some(scheduler) = self.scheduler.upgrade() {
            scheduler.enqueue(self.id); // 将任务 ID 加入就绪队列
        }
    }
}
```
Future 使用 Waker，但不实现它。Waker 的行为由运行时定义。

`sleep`为例，分析
```rust
pub fn sleep(duration: Duration) -> Sleep {
    let location = trace::caller_location(); // 记录调用位置（用于调试/追踪）

    match Instant::now().checked_add(duration) {
        Some(deadline) => Sleep::new_timeout(deadline, location),
        None => Sleep::new_timeout(Instant::far_future(), location),
    }
}
```
* `.checked_add(duration)`：安全加法，如果 duration 太大导致溢出，返回 None
* `Sleep::new_timeout(deadline, location)`：正常路径：创建一个以 deadline 为到期时间的 Sleep

```rust
pub(crate) fn new_timeout(deadline: Instant, location: Option<&Location>) -> Sleep {
    // 1. 获取当前运行时句柄
    let handle = scheduler::Handle::current();
    
    // 2. 创建 TimerEntry（重点）
    let entry = TimerEntry::new(handle, deadline);

    // 3. 【可选】构建 tracing 上下文（仅当启用 tokio_unstable + tracing）
    #[cfg(all(tokio_unstable, feature = "tracing"))]
    let inner = { /* ... */ };

    #[cfg(not(...))]
    let inner = Inner {};

    // 4. 返回 Sleep
    Sleep { inner, entry }
}
```
主要逻辑：获取当前运行时（scheduler + driver），创建一个 `TimerEntry` 并包装进 `Sleep`

这个 `handle` 包含两个关键部分：
* `Executo`r（调度器）：用于任务唤醒（waker.wake() 最终会调用它）
* `Driver`（驱动器）：包含 I/O reactor 和 timer driver

`TimerEntry` 是什么？
* 它是 tokio 内部表示“一个待触发的定时器事件”的结构体
* 但它此时并未注册到 timer heap！
* 它只保存了：到期时间 deadline、对运行时 driver 的弱引用（`Weak<Driver>`）、一个内部 ID（用于后续注册/注销）

```rust
pub struct Sleep {
    inner: Inner, // tracing 上下文（可能为空），调试用途

    entry: TimerEntry, // 定时器入口（核心），负责与 timer driver 交互（注册、注销、查询状态）
}
```

Sleep 的 poll 方法：
```rust
fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> Poll<Self::Output> {
    // 1. 【可选】进入 tracing span（用于调试/追踪）
    #[cfg(...)] let _res_span = ...;
    #[cfg(...)] let _ao_span = ...;
    #[cfg(...)] let _ao_poll_span = ...;

    // 2. 调用 poll_elapsed 并处理结果
    match ready!(self.as_mut().poll_elapsed(cx)) {
        Ok(()) => Poll::Ready(()),
        Err(e) => panic!("timer error: {e}"),
    }
}
```

这里使用了 `ready!` 宏来处理 `Poll::Pending` 状态。所以等价于：
```rust
match self.as_mut().poll_elapsed(cx) {
    Poll::Ready(result) => match result {
        Ok(()) => Poll::Ready(()),
        Err(e) => panic!("timer error: {e}"),
    },
    Poll::Pending => return Poll::Pending,
}
```
关键就在于 `poll_elapsed`

```rust
fn poll_elapsed(self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> Poll<Result<(), Error>> {
    let me = self.project(); // ← 1. 投影字段（用于 Pin 安全访问）

    ready!(crate::trace::trace_leaf(cx)); // ← 2. tracing 叶子节点追踪

    // ← 3. 检查协作预算（coop）
    #[cfg(...tracing...)]
    let coop = ready!(trace_poll_op!("poll_elapsed", crate::task::coop::poll_proceed(cx)));
    #[cfg(...not tracing...)]
    let coop = ready!(crate::task::coop::poll_proceed(cx));

    // ← 4. 调用底层 entry.poll_elapsed，并记录进度
    let result = me.entry.poll_elapsed(cx).map(move |r| {
        coop.made_progress();
        r
    });

    // ← 5. 返回结果（带 tracing 包装）
    #[cfg(...)] return trace_poll_op!("poll_elapsed", result);
    #[cfg(...)] return result;
}
```
coop::poll_proceed() 做了什么？
* 检查当前任务是否还有剩余预算
* 有 → 扣减预算，返回 Poll::Ready(coop)
* 无 → 返回 Poll::Pending，并将当前任务重新入队（让出 CPU）


`entry.poll_elapsed(cx)` 调用 TimerEntry::poll_elapsed，它的逻辑：
* 如果时间已到 → Poll::Ready(Ok(()))
* 否则注册 Waker 并返回 Poll::Pending

```rust
// TimerEntry

pub(crate) fn poll_elapsed(
    mut self: Pin<&mut Self>,
    cx: &mut Context<'_>,
) -> Poll<Result<(), super::Error>> {
    // 1. 检查运行时是否已关闭
    assert!(
        !self.driver().is_shutdown(),
        "{}",
        crate::util::error::RUNTIME_SHUTTING_DOWN_ERROR
    );

    // 2. 如果尚未注册，则调用 reset 进行初始化
    if !self.registered {
        let deadline = self.deadline;
        self.as_mut().reset(deadline, true);
    }

    // 3. 获取 inner（指向 timer driver 中的共享状态）
    let inner = self
        .inner()
        .expect("inner should already be initialized by `self.reset()`");
        
    // 4. 内部保存 waker
    inner.state.poll(cx.waker())
}
```

```rust
// TimerEntry

pub(crate) fn reset(mut self: Pin<&mut Self>, new_time: Instant, reregister: bool) {
    let this = self.as_mut().project();
    *this.deadline = new_time;
    *this.registered = reregister;

    // 将 Instant 转为内部 tick
    let tick = self.driver().time_source().deadline_to_tick(new_time);
    // 确保 inner 已初始化
    let inner = match self.inner() {
        Some(inner) => inner,
        None => {
            self.as_mut().init_inner(); // 如果尚未创建（None），则调用 init_inner()
            self.inner()
                .expect("inner should already be initialized by `this.init_inner()`")
        }
    };

    if inner.extend_expiration(tick).is_ok() {
        return;
    }

    if reregister {
        unsafe {
            // 真正向 timer driver 注册事件的地方
            self.driver()
                .reregister(&self.driver.driver().io, tick, inner.into());
        }
    }
}
```

```rust
//  Handle （time driver）
   pub(self) unsafe fn reregister(
        &self,
        unpark: &IoHandle,
        new_tick: u64,
        entry: NonNull<TimerShared>,
    ) {
        let waker = unsafe {
            let mut lock = self.inner.lock();

            // 防止重复注册
            if unsafe { entry.as_ref().might_be_registered() } {
                lock.wheel.remove(entry);
            }

            // TimerShared 内部包含一个 TimerHandle（轻量级引用），handle() 返回这个 handle，用于插入时间轮
            let entry = entry.as_ref().handle();

            if self.is_shutdown() {
                unsafe { entry.fire(Err(crate::time::error::Error::shutdown())) }
            } else {
                entry.set_expiration(new_tick); // 更新 handle 的到期 tick

                // 插入到 分层时间轮（hierarchical timing wheel），也就是注册
                match unsafe { lock.wheel.insert(entry) } {
                    Ok(when) => {
                        // 决定是否唤醒 I/O 驱动
                        if lock
                            .next_wake
                            .map(|next_wake| when < next_wake.get())
                            .unwrap_or(true)
                        {
                            // 如果新定时器的到期时间比我们当前计划检查时间轮的时间还要早（或者还没有任何计划），那就立刻唤醒 I/O 线程，让它重新规划等待时间，确保新定时器能准时触发。
                            unpark.unpark(); // 用 unpark.unpark() → 唤醒 reactor 线程（如 epoll_wait）
                        }

                        None // Ok 分支返回 None，表示定时器成功插入，尚未触发，不需要立即唤醒任务（等时间到了再 wake）
                    }
                    // 如果插入时发现已过期（InsertError::Elapsed）
                    Err((entry, crate::time::error::InsertError::Elapsed)) => unsafe {
                        entry.fire(Ok(())) // 标记为已完成，取出内部保存的 Waker（如果有的话）
                    },
                }
            }

            // Must release lock before invoking waker to avoid the risk of deadlock.
        };

        // The timer was fired synchronously as a result of the reregistration.
        // Wake the waker; this is needed because we might reset _after_ a poll,
        // and otherwise the task won't be awoken to poll again.
        if let Some(waker) = waker {
            waker.wake();
        }
    }
```

```rust
// TimerEntry
    fn poll(&self, waker: &Waker) -> Poll<TimerResult> {
        // We must register first. This ensures that either `fire` will
        // observe the new waker, or we will observe a racing fire to have set
        // the state, or both.
        self.waker.register_by_ref(waker);

        self.read_state()
    }
```

`Waker` 是在 `TimerEntry::poll_elapsed` 首次返回 `Poll::Pending` 时，通过 `inner.state.poll(cx.waker())` 保存到 `TimeEntry` 持有的 `TimerShared` 中；当时间驱动器发现 timer 到期时，会调用 `entry.fire()`，该方法从 `TimerShared` 的 `AtomicWaker` 中取出 `Waker` 并返回，随后被立即 `wake`。

而 `TimerDriver` 通过 reregister 方法，把 TimerShared 注册进去，sleep时间到了就会取出其中的waker，执行wake()，从而继续poll
Waker的RawWaker中
```rust
pub struct Waker {
    waker: RawWaker,
}

pub struct RawWaker {
    data: *const (),           // 指向 Task 的指针（通常是 Arc<Task>）
    vtable: &'static RawWakerVTable,
}

struct RawWakerVTable {
    clone: unsafe fn(*const ()) -> RawWaker,
    wake: unsafe fn(*const ()),        // 👈 唤醒函数
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ()),
}
```
`wake` 函数由执行器（如 Tokio）提供，它知道如何调度对应的 Task。从而调用到 future 的 poll 方法

Tokio 的 spawn 只会为最外层传入的异步函数创建一个 Task（即一个调度单元）。该 Task 内部嵌套调用的所有 .await（包括其他 async fn）都只是这个 Task 内部的状态机转换，不会产生新的 Task，也不会被单独放入 Tokio 运行时的调度队列中。

嵌套的 async fn 调用在生成的状态机中会被“展开”（flatten），最终形成一个单一、扁平的状态机，而不是嵌套的 Future 堆叠。这避免了动态分发和额外的 poll 调用开销，实现了零成本抽象。

# 面向对象
```rust
pub trait Draw {
    fn draw(&self);
}

pub struct Button {
    pub label: String,
}

pub struct TextField {
    pub placeholder: String,
}

impl Draw for Button {
    fn draw(&self) {
        println!("Drawing button: {}", self.label);
    }
}

impl Draw for TextField {
    fn draw(&self) {
        println!("Drawing text field: {}", self.placeholder);
    }
}
```
在 rust 中，`Button` 和 `TextField` 完全无关（不需要共同父类），可以为任何类型（包括第三方库的类型）实现 Draw


用 `dyn Draw`（trait 对象） 实现多态
```rust
use std::vec::Vec;

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>, // ← 核心！
}

impl Screen {
    pub fn run(&self) {
        for component in &self.components {
            component.draw(); // ← 动态分发，类似 Java virtual call
        }
    }
}

// 使用示例
let screen = Screen {
    components: vec![
        Box::new(Button { label: "OK".into() }),
        Box::new(TextField { placeholder: "Enter name".into() }),
    ],
};
screen.run();
```
**Rust 的多态 = 接口（trait） + 动态分发（dyn）**

> 使用 `dyn Trait` 是动态分发，自然会略高一点性能开销

# 高级特性
## unsafe
正常情况下，Rust 在编译时会强制执行的内存安全保证，但因为底层计算机硬件固有的不安全性，如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了。所以使用 `unsafe` 可以开启一个包含不安全代码的新块。

这里有五类只能在 unsafe Rust 中进行的操作，包括：
* 解引用裸指针（比如用于与 C 交互）
* 调用不安全的函数或方法
* 访问或修改可变静态变量
* 实现不安全 trait（比如手动实现 Send/Sync）
* 访问 union 的字段

但 unsafe 并不会关闭借用检查器或禁用任何其他 Rust 安全检查，unsafe 关键字只是提供了这五个不会被编译器检查内存安全的功能。

### 解引用裸指针
```rust
let mut num = 5;
let r1 = &raw const num; // 安全：创建裸指针无需 unsafe
let r2 = &raw mut num;

unsafe {
    println!("{}", *r1); // 必须在 unsafe 块中解引用
}
```

###  FFI（外部函数接口）
```rust
unsafe extern "C" {
    fn abs(input: i32) -> i32; // C 函数默认 unsafe
}

// 若确定安全，可标记为 safe（仍需 unsafe extern 块）
unsafe extern "C" {
    safe fn abs(input: i32) -> i32;
}
```


## 高级类型
1. `别名`
```rust
type Kilometers = i32;

type Thunk = Box<dyn Fn() + Send + 'static>;
```

2. `newtype`
定义一个只包含单个字段的元组结构体（tuple struct），为现有类型创建一个语义不同、类型安全的新类型。
```rust
struct Meters(i32);
struct Kilograms(i32);

fn calculate_bmi(height: Meters, weight: Kilograms) -> f32 {
    // ...
}
```
可以防止例如意外混用字符串（`Password(String)` vs `Username(String)`），别名无法提供这样的安全性

3. 从不返回的 `never type`
也叫`empty type`，表示永远不会返回的类型。函数返回 ! 意味着它一定会 panic、死循环或退出程序。
```rust
fn never_returns() -> ! {
    panic!("This function never returns!");
}

fn exit_now() -> ! {
    std::process::exit(1);
}
```

它可转换为任何类型：因为“永远不会产生值”，所以能赋给任何变量。表示“不可能发生”的分支（如匹配空枚举）
```rust
let x: i32 = match some_option {
    Some(v) => v,
    None => panic!("No value!"), // panic 返回 !
};
```

4. 动态大小类型和 Sized trait
动态大小类型（`Dynamically Sized Type`，简称 DST）是 Rust 中编译期无法确定大小、仅运行时可知大小的类型；但 Rust 要求栈上分配的值必须是编译时已知的、固定的大小。所以我们会发现如果使用`str`（不是`&str`），无法使用创建 `str` 类型的变量：
```rust
let s1: str = "hello there!";        // ❌ 错误！str 是 DST，不能直接放在栈上
let s2: str = "How's it going?";
```
`s1`、`s2`的长度分别是12、15个字节，`str`类型的大小是在运行时动态确定，但rust希望同一个类型应该有相同并且固定的长度，所以无法创建一个存放动态大小类型的变量。

这里重新分析一下关于字符串的三种类型：
* `str`：Rust 字符串的 “底层原始类型”，代表一段连续的 UTF-8 字节序列，但它没有自带长度信息，所以`str`是动态大小类型
* `String`：类型变量在栈上包含指向堆上 UTF-8 字节的指针、字符串当前有效长度和堆内存总容量3个方面的字段，所以是 `Sized trait`
* `&str` 在栈上固定存储两部分信息：数据指针（指向 str 实际 UTF-8 字节的起始地址）和 长度 （str 对应的字节序列长度），所以是 `Sized trait`

> `String`和`&str`本质上都是字符串的栈上指针数据，那么为什么不设计其中一个类型就行？因为`&str`是只读视图，不拥有指向的内存，必须依赖原数据的生命周期；而 `String` 拥有堆内存所有权，可自由转移 / 返回，不受其他数据生命周期约束。

以 `str` 为例，除了通过 `&str` 引用可以直接创建，还可以使用 `Box<str>` 或 `Rc<str>` 等方式，总之就是须将动态大小类型的值置于某种指针之后，或者说必须通过某种指针间接引用。


而`Sized trait` 是 Rust 标记 “编译期大小固定类型” 的核心 trait，几乎所有基础类型（`i32`、`bool`、`&T`、`[T; N]` 等）、自定义结构体 / 枚举（如果所有字段均为 Sized）会自动实现 Sized。

Rust 为所有泛型隐式添加 Sized 约束：
```rust
fn foo<T>(x: T) { } 
// 实际等价于：
fn foo<T: Sized>(x: T) { }
```
`T` 不能是 `[i32]`、`str`、`dyn Trait` 等动态大小类型。

使用 `?Sized` 可以取消默认的 `Sized` 约束：
```rust
// 允许 T 是 DST（如 str, [u8], dyn Debug）
fn print_it<T: std::fmt::Display + ?Sized>(x: &T) {
    println!("{}", x);
}

// 使用示例
print_it("hello");   // T = str （!Sized）
print_it(&42);       // T = i32 （Sized）
```

## 高级函数和闭包
函数指针
```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}
```
不同于闭包，`fn` 是一个类型而不是一个 `trait`，所以直接指定 `fn` 作为参数而不是声明一个带有 `Fn` 作为 `trait bound` 的泛型参数。函数指针实现了所有三个闭包 trait（Fn、FnMut 和 FnOnce），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。

## 宏
Rust 有两种宏：
1. 使用 macro_rules! 的声明宏（declarative macro），这是最常用的宏
2. 过程宏（Procedural Macros）功能更强大，分为3种：
  * 自定义 `#[derive]` 宏，用于在结构体和枚举上通过添加 `derive` 属性生成代码
  * 类属性宏，定义可用于任意项的自定义属性
  * 类函数宏，看起来像函数，但操作的是作为其参数传递的 token

从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）。

### 声明宏
首先看一下`vec!`这个声明宏的写法：
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```
#### 步骤 1：模式匹配
`( $( $x:expr ),* )` 是一个模式：
  * `$x:expr`：匹配任意表达式（如 1, "hello", foo()）
  * `$( ... ),*`：表示“零个或多个，用逗号分隔”

所以 vec![1, 2, 3] 会被这个模式匹配！

#### 步骤 2：代码生成
`$x` 在右侧被重复展开：
```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

宏的常见模式语法：
* `$x:expr`：匹配任意表达式
* `$x:ident`：匹配标识符（变量名、函数名等）
* `$x:ty`：匹配类型
* `$( ... )*`：零次或多次重复
* `$( ... )+`：一次或多次重复
* `$( ... ),*`：用逗号分隔的零次或多次

### 过程宏
当看到这些代码时，背后就是过程宏：
```rust
#[derive(Debug, Clone)]  // ← 自定义 derive 宏
struct Point { x: i32, y: i32 }

#[tokio::main]           // ← 类属性宏
async fn main() { ... }

let query = sql!(SELECT * FROM users WHERE id = 1); // ← 类函数宏
```
过程宏用 Rust 代码解析并生成代码，需要单独的 `proc-macro` crate。（感觉和Java的APT、Kotlin的KSP的作用类似）