## 2. 有意义的命名
* 命名要名副其实：变量、函数或类的名称已经表明了主要的意图
* 避免误导，做有意义的区分
* 使用可搜索的名称。例如找到MAX_STUDENT_COUNT很容易，而e这个字母到处都会出现
* 避免使用编码：例如没有避免在成员变量前加m（Java中常见）；没必要在接口前加I
* 类名和对象名应该是名称或名词短语，方法名应该是动词或动词短语
* 每个概念对应一个词，并且一以贯之。例如fetch、retrive和get，又例如controller、manager和driver；我们应该选择其中一个，而不要混着使用
* 别用双关语，例如增加一个值到现有集合中，应该用insert或append，而add用于新增后返回新的集合
* 添加有意义的语境。假设有firstName、lastName、city、state的变了，它们放在一起时可以看出来是表示地址，但如果单独看到一个state，不容易知道是地址的一部分，可以添加前缀addrFirstName、addrState。当然，更好的是创建一个Address类，这样就知道state是隶属于地址。
* 不要添加没用的语境。例如Address如果可以表达出当前项目中的含义，就没有必要写成AccountAddress。如果需要和MAC地址、端口地址区分，那么需要考虑使用PostalAddress、MAC

## 3. 函数
* 函数的第一规则是要短小
* 只做一件事。要确保函数只做一件事，函数的语句都要在同一抽象层级上
* 利用多态，减少或隐藏switch或if的分支语句
* 使用描述性的名称。函数越短小、功能越集中，越容易取好名字。别害怕长名称，长而具有描述性的名词，比短而令人费解的名称好，也比描述性的长注释好。命名要保持一致、一脉相承。writeField(name)比write(name)更好，因为可以知道name是一个field
* 参数少更好。返回值比修改输入的引用参数更好；布尔参数不如分为两个函数；减少二元参数，例如foo(a: A, b: B)可以视情况转换为成员函数A.fun(b: B)；参数过多，可以封装为类
* 无副作用。
* 分隔指令和访问。函数要么做什么事，要么回答什么事。如果两样都做会导致混乱。例如常见的if(set(..))，既修改了状态，又返回是否设置成功；更好的是if(exist) set(..) else ...
* 使用异常替代返回错误码。可以避免函数嵌套；也可以从主路径代码中分离出来，简化代码。抽离try-catch，将try-catch中的主体代码块抽离为函数
* 避免重复代码
* 可以通过多个函数的参数和返回值，明确函数调用的时序
* 先写出来，再打磨它

## 4. 注释
* 注释不能美化代码，最好是把代码弄干净
* 尽量利用函数名称传达信息
* 注释可以解释某个决定的意图
* 表达警示
* 避免废话

## 6. 对象和数据结构
* 数据抽象、封装、隐藏内部结构
* 数据和对象的对立性。对象把数据隐藏，暴露操作数据的函数，而数据结构暴露数据，不提供有意义的函数。以策略模式为例，如果使用过程式代码（例如if-else）则便于在不改动既有数据结构的前提下添加新的函数；而多态式代码则便于在不改动既有函数的前提下添加新类。反过来说，过程式代码难以添加新数据结构，因为需要修改所有函数；而面向对象的多态代码，难以添加新函数，因为要修改所有数据结构类。

## 7. 错误处理
* 使用异常而非返回码
* 确定try-catch的范围
* Java的受检异常设计，容易导致从高到低层次的函数都必须添加异常签名，破坏了封装。Kotlin的异常更佳
* 说明异常发生的情况
* 根据情况，可以封装底层的多个异常为一个异常，抛出给上层
* 减少异常。例如返回列表时，异常情况返回一个空列表

## 9. 单元测试
* 测试代码也要保持整洁
* 测试要相互独立

## 10. 类
* 类应该短小。单一职责原则。系统应该有许多短小的类而不是少量巨大的类组成
* 内聚。如果一个类中的每个变量都被每个方法使用，则该类具有最大的内聚性，但一般来说创建这种极大化的内聚类是不可能的。内聚性高，意味着类中的方法和变量相互依赖、互相结合成一个逻辑整体。当类丧失了内聚性，就拆分它

## 11. 系统
* 分离构造和使用。使用工厂模式、依赖注入
* 面向切面编程。需要使用aop框架
* 重构。提升内聚、降低耦合、模块化、缩小函数和类
* 减少重复。可以抽离代码、使用设计模式
