参考 [字符集编码详解](https://blog.csdn.net/qq_42068856/article/details/83792174)
# Java的字符编码
Java中的 char 数据类型是一个采用UTF-16编码表示Unicode代码点的代码单元，大多数的常用Unicode字符使用一个代码单元就可以表示，而增补字符需要一对代码单元表示。我们所熟知的String类型的length方法，它返回的是UTF-16编码表示的给定字符串的代码单元的数量，如果想要得到代码点的数量，可以调用codePointCount()方法

Java的字符串在内部使用的是UTF-16，但是使用时是会根据本机编码或者指定编码转换，比如调用 "a".getBytes()，因为本机是UTF-8，所以得到是UTF-8字符编码

# 编码规范中的三个子概念
&emsp;&emsp;字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。对于一个字符集来说要正确编码转码一个字符
需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）。

1. 字库表  
   字库表是某个编码规范中所有能显示的所有字符。例如：几乎所有汉字都保存在GBK 编码规范的字库表中。所以可以显示汉字，但法语，俄语并不在其字库表中，所以GBK不能显示法语，俄语等。

2. 编码字符集（字符集）  
    在一个字库表中，每一个字符都有一个对应的二进制地址（code point），而编码字符集就是这些地址的集合。

    例如：在ASCII码的编码字符集中，字母A的序号（地址）是65，65的二进制就是01000001。我们可以说编码字符集就是用来存储这些二进制数的。而这个二进制数就是编码字符集中的一个元素，同时它也是字库表中字母A的地址。我们根据这个地址就可以显示出字母A。

3. 字符编码（编码方式）  
    通过字库表和编码字符集，可以通过二进制地址得到字符，但是，直接使用字符对应的二进制地址来显示文字十分浪费空间，Unicode 编码规范中包括了几百万个字符，想要包括几百万个不同的字符，起码需要3个字节的容量，为了方便将来扩展，Unicode还保留了更多未使用的空间，最多可以存储4个字节的容量。
    
    因此为了区分每个字符，即使是00000000 00000000 00000000 00001111这种其实只占了1个字节的字符，我们也要为他分配4个字节的空间，所以我们需要一套算法来节省空间，每一种算法都被称为一种字符编码方式。

    于是就出现了UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。

    所以，字符编码就是用来将一个较短的二进制数转换为编码字符集中正常的地址。

# UTF-8和Unicode的关系
通过上述概念，UTF-8和Unicode的关系就比较明显了。Unicode就是上文中提到的编码字符集，而UTF-8就是字符编码。随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。它几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。详见：
Unicode on Wikipedia。Unicode的编号从0000开始一直到10FFFF共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，可见UTF-8虽然是
一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难（下文会有提到）。  

# UTF-8编码简介
为了更好的理解后面的实际应用，我们这里简单的介绍下UTF-8的编码实现方法。即UTF-8的物理存储和Unicode序号的转换关系。
UTF-8编码为变长编码。最小编码单位（code unit）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。

* 如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。
* 如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二个字节以10开头
* 如果一个字节以1110开头，那么代表当前字符为三字节字符，占用3个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二、第三个字节以10开头
* 如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）代表在Unicode中的序号。  

具体每个字节的特征可见下表，其中x代表序号部分，把各个字节中的所有x部分拼接在一起就组成了在Unicode字库中的序号

| Byte 1 | Byte 2 | Byte 3 | 
| - | :-: | -: | 
| 0xxx xxxx | |  | 
| 110x xxxx | 10xx xxxx |  | 
| 1110 xxxx | 10xx xxxx | 10xx xxxx |

我们分别看三个从一个字节到三个字节的UTF-8编码例子：

| 实际字符 | 在Unicode字库序号的十六进制 | 在Unicode字库序号的二进制 | UTF-8编码后的二进制 | UTF-8编码后的十六进制 |
| - | :-: | -: | -: | -: | 
| $ | 0024 | 010 0100 | 0010 0100 | 24 |
| ¢ | 00A2 | 	000 1010 0010 | 1100 0010 1010 0010 | C2 A2 |
| € | 20AC | 0010 0000 1010 1100 | 1110 0010 1000 0010 1010 1100 | E2 82 AC |

不难从以上的简单介绍中得出以下规律：

* 3个字节的UTF-8十六进制编码一定是以E开头的
* 2个字节的UTF-8十六进制编码一定是以C或D开头的
* 1个字节的UTF-8十六进制编码一定是以比8小的数字开头的

# 为什么会出现乱码

简单的说乱码的出现是因为：编码和解码时用了不同或者不兼容的字符集。对应到真实生活中，就好比是一个英国人为了表示祝福在纸上写了bless（编码过程）。而一个
法国人拿到了这张纸，由于在法语中bless表示受伤的意思，所以认为他想表达的是受伤（解码过程）。这个就是一个现实生活中的乱码情况。在计算机科学中一样，一个用UTF-8编码后的字符，用GBK去解码。由于两个字符集的字库表不一样，同一个汉字在两个字符表的位置也不同，最终就会出现乱码。

我们来看一个例子：假设我们用UTF-8编码存储很屌两个字，会有如下转换：

| Byte 1 | Byte 2 |
| - | :-: |
| 很 | E5BE88 |
| 屌 | E5B18C |

于是我们得到了E5BE88E5B18C这么一串数值。而显示时我们用GBK解码进行展示，通过查表我们获得以下信息：

| 两个字节的十六进制数值 | GBK解码后对应的字符 | 
| - | :-: |
| E5BE | 寰 |
| 88E5 | 堝 |
| B18C | 睂 |
