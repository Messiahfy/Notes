## 变量和基本类型
使用new，可以把数据开辟到堆区，使用delete释放。C++的类的构造函数一般不用new调用，创建在栈区，使用new则创建在堆区

引用的本质是一个指针常量

## 面向对象程序设计
### 对象的拷贝构造、拷贝赋值
拷贝构造函数使用传入对象的值生成一个新的对象的实例，而拷贝赋值运算符将对象的每个成员变量的值赋值给一个已经存在的实例。

将对象传递给函数的形参、或者函数返回一个对象，都会执行拷贝构造函数，因为这些情况都会创建临时对象实例。如果返回的对象是引用的方式，那么会执行拷贝赋值。

默认都属于浅拷贝

### 对象的移动
左值引用（就是平时常用的&a=b）的右值不能是一个临时值：
```
std::string foo()
{
    return std::string("abc");
}

int main() {
    std::string s3 = foo();//foo()中构造了临时变量，然后又调用拷贝构造函数构造s3
    const std::string &s = foo();//左值引用，要么加const，要么右侧改为另一个变量，比如s3
    std::string &&s2 = foo();//右值引用，可以直接绑定临时变量，也就是把该临时变量直接作为s2
}
```
对象的移动，也就是用右值引用直接接管一个临时变量。对应的，可以自定义移动构造函数

### 继承
* 继承的函数，属于静态分派，也就是按声明类型调用方法；设为虚函数，子类重写父类的虚函数，可以变为动态分派，也就是按实际类型调用方法
* 不实现虚函数，即纯虚函数，有了纯虚函数，类就成为抽象类
* 虚继承：针对多重继承的问题
* 虚析构函数，子类的析构函数才能被执行。纯虚析构函数，也可以使类成为抽象类

## 模板（泛型）
模板分为`函数模板`和`类模板`

### 函数模板
```
template<typename T>
//或者 template<class T>
void swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
```

### 类模板
```
template<typename T>
//或者 template<class T>
class Person{
    
}
```
类模板没有自动类型推导，创建对象时，类型需要写上尖括号和类型。且类模板的模板类型可以写默认类型

类模板的成员函数在运行时才创建