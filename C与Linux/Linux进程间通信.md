## 1.进程
&emsp;&emsp;进程是程序执行时的一个实例，操作系统使用进程描述符管理进程。进程包含可执行程序代码，还有其他资源，比如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间和一个或多个执行线程，和存放全局变量的数据段等（寄存器）。进程就是正在执行的程序代码的实时结果。  
&emsp;&emsp;线程是进程中活动的对象，每个线程都拥有独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。在Linux中，线程只是一种特殊的进程。  
&emsp;&emsp;现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虽然实际上可能有许多进程在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程认为自己在独享处理器。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。线程之间可以共享虚拟内存，但各自拥有独立的虚拟处理器。  
&emsp;&emsp;程序本身不是进程，进程是处于执行期的程序以及相关的资源的总称。

#### 创建进程
&emsp;&emsp;在Linux系统中，通常进程创建是调用`fork()`的结果，该系统调用通过复制一个现有的进程来创建一个全新的进程，调用`fork()`的进程成为父进程，新产生的进程成为子进程。在该调用结束时，在返回点这个相同的位置上，父进程恢复执行，子进程开始执行。`fork()`系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。

&emsp;&emsp;通常，创建新的进程是为了执行不同的新的、不同的程序，而接着调用`exec()`函数可以创建新的地址空间，并把新的程序载入其中。在现代Linux内核中，`fork()`实际是由`clone()`系统调用实现的。

&emsp;&emsp;最终，程序通过`exit()`系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过`wait4()`系统调用查询子进程是否终结，这其实使进程拥有了等待特定进程执行完毕的能力。

#### 进程描述符及任务结构
&emsp;&emsp;内核把进程的列表放在叫做任务队列（task list）的双向循环链表中。链表中的每一项都是类型为`task_struct`、成为进程描述符（`process description`）的结构，该结构定义在<linux/sched.h>文件中。进程描述符包含了一个具体进程的所有信息，：它打开的文件，进程的地址空间，挂起的信号，进程的状态，pid，还有其他更多信息。

#### 进程上下文
&emsp;&emsp;可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行，当一个程序调用了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。

## 2.线程在Linux中的实现
&emsp;&emsp;线程机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。

&emsp;&emsp;Linux实现线程的机制非常独特，从内核的角度来说，它并没有线程这个概念，Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程，相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个进程都拥有唯一的隶属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程。

&emsp;&emsp;上述线程机制的实现与Microsoft Windows或是Sun Solaris等操作系统的实现差异非常大，这些系统都在内核中提供了专门支持线程的机制。假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包含指向四个不同线程的指针的进程描述符，该描述符复制描述像地址空间、打开的文件这样的共享资源，线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的task_struct结构，建立这四个进程时指定他们共享某些资源。

## 3.进程终结
&emsp;&emsp;当一个进程终结时，内核必须释放它所占有的资源并把此情况告知其父进程。进程的终结发生在调用`exit()`系统调用时，既可能显式地调用这个系统调用，也可能隐式地从某个程序的主函数返回（其实C语言编译器会在`main()`函数的返回点后面放置调用`exit()`的代码）。当进程接受到它既不能处理也不能忽略的信号或异常时，它还可能被动地终结。不管进程是怎么终结的，该任务大部分都要靠do_exit()来完成，它要做下面这些工作：
1. 将task_struct中的标志成员设置为PF_EXITING
2. 调用del_timer_sync()删除任一内核计时器，根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。
3. 如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记账信息。
4. 然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是和这个地址空间没有被共享），就彻底释放它们。
5. 接下来调用sem_exit()函数，如果进程排队等候IPC信号，它则离开队列。
6. 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值将为零，那么就代表没有进程在使用相应的资源，此时可以释放。
7. 接着把存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作，退出代码存放在这里供父进程随时检索。
8. 调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init线程，并把线程状态设为EXIT_ZOMBIE。
9. do_exit()调用schedule（）切换到新的进程，因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码，do_exit()永不返回。

#### 删除进程描述符
&emsp;&emsp;在调用了do_exit()之后，尽管进程已经僵死不能再运行了，但是系统还保留了它的进程描述符，这样做可以让系统有办法在子进程终结后仍能获得它的信息，因此，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。

## 4.进程间通信
#### 管道pipe与命名管道fifo
最适合在进程之间实现生产者/消费者的交互。管道是进程之间的一个单向数据流：一个进程写入管道的所有数据都由内核定向到另一个进程，另一个进程由此就可以从管道中读取数据。在shell中，可以使用“|”操作符来创建管道。

可以使用`pipe()`系统调用来创建一个新管道，这个系统调用返回**一对文件描述符**，然后进程通过`fork()`把描述符传给它的子进程。  
进程可以在`read()`系统调用中使用第一个文件描述符从管道中读数据，同样也可以在`write()`系统调用中使用第二个文件描述符向管道中写入数据。  
管道在Linux中是半双工的（单向），只能在父子进程中使用。

虽然管道是一种简单、灵活、有效的通信机制，但它有一个主要缺点，就是无法打开已存在的管道。这就使得任意的两个进程无法使用管道通信，除非管道由一个共同的祖先进程创建。为了突破这种限制，引入了命名管道（或者称为`FIFO`表示先进先出，最先写入文件的字节被最先读出）的特殊文件类型。fifo和管道都和一个内核缓冲区相关联，最大差别在于FIFO在文件系统中拥有一个名称，并且打开方式与打开一个普通文件是一样的，进程通过`mkfifo()`创建一个fifo，然后就可以使用普通的`open()`，`read()`，`write()`和`close()`访问fifo。

#### 信号量Semaphore
信号量仅仅是一个与数据结构相关的计数器。所有内核线程访问这个数据结构前，都要检查这个信号量。它主要用在多个进程需要对共享数据进行访问的时候，实现进程间的互斥与同步，而不是用于存储进程间通信数据，若要在进程间传递数据需要结合共享内存。考虑这一的情况，不能同时有两个进程对同一数据进行访问，那么借助信号量就可以完成这样的事情。

它的主要流程如下：

检查控制该资源的信号量
如果信号量值大于0，则资源可用，并且将其减1，表示当前已被使用
如果信号量值为0，则进程休眠直至信号量值大于0
也就是说，它实际上是提供了一个不同进程或者进程的不同线程之间访问同步的手段。

#### 共享内存SharedMemory
允许进程通过共享内存块来交换信息。在必须共享大量数据的应用中，这可能是最高效的进程通信方式。最有用的IPC机制是共享内存，这种机制允许多个进程通过把公共数据结构放入一个共享内存区来访问它们。如果进程要访问这种存放在共享内存区的数据结构，就必须在自己的地址空间中增加一个新内存区，它将映射与这个共享内存区相关的页框，这样的页框很容易地由内核通过调页进行处理。IPC的共享内存指的是把所有的共享数据放在共享内存区域（IPC shared memory region），任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。和mmap系统调用通过映射一个普通文件实现共享内存不同，UNIX system V共享内存是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。

共享内存有两种实现方式：
1. UNIX System V共享内存机制
2. 内存映射

内存映射（mapped memory）机制使进程之间通过映射同一个普通文件实现共享内存，通过mmap()系统调用实现。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数。

总结：
1. mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间进行映射。而对于shm而言，shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大
2. mmap使用更简单
3. mmap有一个好处是当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失。

#### 消息队列MessageQueue
进程产生的每条消息发送到一个IPC消息队列中，这个消息一直存放在队列中直到另一个进程将其读走为止。
```
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

> 一般都是结合多种进程间通信方式来实现复杂的实际应用，例如通过消息队列发送通知，信号量控制同步，共享内存传输实际数据。

#### 套接字Socket

#### 信号 (sinal)
信号提供了把系统事件报告给进程的一种机制

#### 文件锁

[参考](http://songlee24.github.io/2015/04/21/linux-IPC/)
[mmap映射区和shm共享内存的区别](https://blog.csdn.net/hj605635529/article/details/73163513)