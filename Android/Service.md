# Services
&emsp;&emsp;Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台
继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交
互，而所有这一切均可在后台进行。  

服务基本上分为两种形式：  

* **started(启动)** 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服
务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止
运行。  

* **Bound(绑定)** 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发
送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定
后，该服务才会被销毁。

> 服务可以前台运行或者后台运行。前台服务执行一些对用户来说很明显的操作。 例如，音频应用程序会使用前台服务播放音轨。 前台服务必须显示状态栏图标。 即使用户
未与应用程序交互，前台服务也会继续运行。后台服务执行用户不直接注意的操作。 例如，如果应用程序使用服务来压缩其存储，那通常是后台服务。  
> **注意**：如果您的应用程序的目标是API级别26或更高，则当应用程序本身不在前台时，系统会对[运行后台服务施加限制](https://developer.android.google.cn/about/versions/oreo/background.html)。 在大多数情况下，您的应用程序应该使用
[scheduled job](https://developer.android.google.cn/topic/performance/scheduling.html)(预定作业)。  

&emsp;&emsp;虽然本文档是分开概括讨论这两种服务，但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是
在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。  

&emsp;&emsp;无论应用是处于启动状态还是绑定状态，或同时处于启动和绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来
自另一应用）。不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。 使用清单文件声明服务部分将对此做更详尽的阐述。  
> 注意：服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止
性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继
续专注于运行用户与 Activity 之间的交互。  

## 基础知识
&emsp;&emsp;要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件
绑定到服务（如适用）。 应重写的最重要的回调方法包括：  

**onStartCommand\(\)** 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法，即使该服务已被启动。一旦执行此方法，服务即会启动并可在后台
无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。）  

**onBind\(\)** 当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个
接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。  

**onCreate\(\)** 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。  

**onDestroy()** 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。

&emsp;&emsp;如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。  

&emsp;&emsp;如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。

&emsp;&emsp;仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可
能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列
表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再
次可用，系统便会重启服务（不过这还取决于从 onStartCommand() 返回的值，本文稍后会对此加以讨论）。如需了解有关系统会在何时销毁服务的详细信息，请参阅[进
程和线程](https://developer.android.google.cn/guide/components/processes-and-threads.html)文档。  

### 使用清单文件声明服务
如同 Activity（以及其他组件）一样，您必须在应用的清单文件中声明所有服务。

要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：
```
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```
如需了解有关使用清单文件声明服务的详细信息，请参阅 <service> 元素参考文档。

您还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名
。应用一旦发布，即不应更改此类名，如若不然，可能会存在因依赖显式 Intent 启动或绑定服务而破坏代码的风险（请阅读博客文章Things That Cannot Change[不能
更改的内容]）。

> **注意**：为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。使用隐式Intent启动服务会带来安全隐患，因为您无法确定将响应该Intent的服务，并且用户无法看到启动哪项服务。 从Android 5.0（API级别21）开始，如果您以隐式意图调用bindService（），则系统会引发异常。

此外，还可以通过添加 android:exported 属性并将其设置为 "false"，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。
> **注意**：用户可以查看其设备上正在运行的服务。 如果他们看到他们不认识或不信任的服务，他们可以停止服务。 为了避免用户意外停止服务，您需要将android：description属性添加到应用清单中的<service>元素。 在描述中，提供一个简短的语句来解释服务的作用以及它提供的好处。

## 创建started(启动)服务
&emsp;&emsp;启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。

&emsp;&emsp;服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束
工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。

&emsp;&emsp;应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。

&emsp;&emsp;例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要
保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。  

> **注意**：注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行
交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，您应在服务内启动新线程。  

从传统上讲，您可以扩展两个类来创建启动服务：  
**Service** 这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行
的所有 Activity 的性能。  

**IntentService** 这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。   

&emsp;&emsp;onStartCommand（Intent intent, int flags, int startId）的三个参数含义如下：  
* intent：startService(Intent intent)中传递的intent。如果服务在其进程消失后重新启动，它可能为空
* flags：表示启动请求的方式，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：
  * START_FLAG_REDELIVERY 表明intent是先前传递的intent的重新传递，因为服务在先前已经返回了 START_REDELIVER_INTENT ，
  * START_FLAG_RETRY 该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。
* startId：指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。
&emsp;&emsp;请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务被系统杀死的情况下继续运行服务（如上所述，IntentService 的默
认实现将为您处理这种情况，不过您可以对其进行修改）。从 onStartCommand() 返回的值必须是以下常量之一：  

**START_NOT_STICKY**    如果因内存不足系统在 onStartCommand() 返回后杀死服务，则除非有挂起 Intent 要传递，否则即使内存空闲系统也不会重建服务。这是最安全的选项，可以避免在不
必要时以及应用能够轻松重启所有未完成的作业时运行服务。  

**START_STICKY**    如果因内存不足系统在 onStartCommand() 返回后杀死服务，则会在内存空闲时重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有
挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作
业的媒体播放器（或类似服务）。  

**START_REDELIVER_INTENT**    如果因内存不足系统在 onStartCommand() 返回后杀死服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。
任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。
