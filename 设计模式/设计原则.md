#### 单一职责原则
单一职责原则主要讨论的是函数和类之间的关系。任何一个软件模块都应该只对某一类行为者负责。例如，虽然一个Employee类中的函数都是处理员工相关的业务，但需要满足多种用户的要求，那么就很容易因为满足不同用户的需求，导致耦合和混乱，所以这个Employee类仍然需要根据具体情况来分离。

#### 开闭原则 
一个设计良好的系统应该在不需要修改原有代码的前提下就可以轻易被扩展。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。

#### 里氏替换原则
所有引用基类的地方必须能透明地使用其子类的对象。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误或异常，反之不成立。里氏替换原则是实现开闭原则的重要方式之一。  
在使用里氏替换原则时，需要注意：
1. 子类所有的方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中经常使用父类来进行定义，如果一个方法只存在于子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
2. 运用里氏替换原则时，尽量把父类设计为抽象类或接口，让子类继承或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能。

反例：正方形继承长方形，正方形的宽和高需要保持一致，所以setHeight(int)和setWidth(int)在正方形情况下会出现异常，这种情况不符合里氏替换原则，此时应该让正方形和长方形继承更上层的四边形类或接口，正方形和长方形是平级的类。

如果不符合里氏替换原则，代码中就会夹杂一些特例处理代码，留下隐患。

#### 依赖倒置原则
如果说开闭原则是面向对象设计的目标的话，那么依赖倒置原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒置原则的主旨：如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。换言之，要针对接口编程，而不是针对实现编程。当然，开始就设计一个稳定、尽量不会变动的接口是前提。依赖倒置主要关注的是软件系统内部那些会经常变动的具体实现模块，而对于稳定的操作系统、平台设施不必考虑。

源代码依赖方式永远是控制流方向的反转，这就是依赖倒置的由来。实现依赖倒置原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中。常用的注入方式有三种：构造注入、Setter注入和接口注入。

大多数时候，开闭原则、里氏替换原则和依赖倒置原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段。

#### 接口隔离原则
使用多个专门的接口，而不使用单一的的总接口，即客户端不应该依赖那些它不需要的接口。当一个接口太大时，我们需要把它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。也可以避免某些实现类实际上不需要实现该方法，却不得不写一个空方法。任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。

#### 合成复用原则
又称组合/聚合复用原则，定义：尽量使用对象组合（也就是组合/聚合关系），而不是继承来达到复用的目的。

面向对象设计中，可以通过组合/聚合或者继承来复用已有的设计和实现，但应该优先考虑组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，使用继承时，需严格遵守里氏替换原则，有效使用继承可以降低复杂度，而滥用继承反而会增加构建维护难度和复杂度。

继承复用的主要的问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，又称白箱复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承来的实现是静态的，不能在运行时改变，不够灵活；而且继承在某些情况不能使用，比如Java中声明final。

由于组合/聚合关系可以将已有对象（也可称成员对象）纳入新对象中，因此新对象可以调用已有对象的功能，这样可以使得成员对象的内部实现细节对新对象不可见，又称黑箱复用，相对继承而言，耦合度相对较低，成员对象的变化对新对象的影响不大；合成复用可以在运行时动态进行，新对象可以引用与成员对象类型相同的其他对象。

#### 迪米特原则
一个软件实体应当尽可能少地与其他实体发生相互作用。考虑通过引入一个合理的第三者来降低现有对象直接的耦合度，例如EventBus作为数据中转。

在类的划分上，应当尽量创建松耦合的类，类的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的设计结构上，每一个类都应当尽量降低成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

#### 组件构建原则
软件系统应该分为多个可以独立开发的组件，应该将会同时修改并且为相同目的修改的类放到同一个组件中。那么组件的修改就只需要考虑不要影响依赖此组件的上层组件，而不需要考虑此组件依赖的下层组件，解除牵一发而动全身的耦合。