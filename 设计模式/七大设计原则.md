#### 单一职责原则
一个类只负责一个功能领域中的相应职责，或者说，就一个类而言，应该只有一个引起它变化的原因。

#### 开闭原则 
一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。软件实体可以指一个软件模块、一个或多个类组成的局部结构或一个独立的类。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。

#### 里氏替换原则
所有引用基类的地方必须能透明地使用其子类的对象。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误或异常，反之不成立。里氏替换原则是实现开闭原则的重要方式之一。  
在使用里氏替换原则时，需要注意：
1. 子类所有的方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中经常使用父类来进行定义，如果一个方法只存在于子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
2. 运用里氏替换原则时，尽量把父类设计为抽象类或接口，让子类继承或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能。

#### 依赖倒置原则
如果说开闭原则是面向对象设计的目标的话，那么依赖倒置原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。定义：抽象不应该依赖于细节，细节应该依赖于抽象，换言之，要针对接口编程，而不是针对实现编程。引入抽象后，系统将具有很好的灵活性，在程序中尽量使用抽象层编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，符合开闭原则。

实现依赖倒置原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中。常用的注入方式有三种：构造注入、Setter注入和接口注入。

大多数时候，开闭原则、里氏替换原则和依赖倒置原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段。

#### 接口隔离原则
使用多个专门的接口，而不使用单一的的总接口，即客户端不应该依赖那些它不需要的接口。当一个接口太大时，我们需要把它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。也可以避免某些实现类实际上不需要实现该方法，却不得不写一个空方法。

#### 合成复用原则
又称组合/聚合复用原则，定义：尽量使用对象组合（也就是组合/聚合关系），而不是继承来达到复用的目的。

面向对象设计中，可以通过组合/聚合或者继承来复用已有的设计和实现，但应该优先考虑组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，使用继承时，需严格遵守里氏替换原则，有效使用继承可以降低复杂度，而滥用继承反而会增加构建维护难度和复杂度。

继承复用的主要的问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，又称白箱复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承来的实现是静态的，不能在运行时改变，不够灵活；而且继承在某些情况不能使用，比如Java中声明final。

由于组合/聚合关系可以将已有对象（也可称成员对象）纳入新对象中，因此新对象可以调用已有对象的功能，这样可以使得成员对象的内部实现细节对新对象不可见，又称黑箱复用，相对继承而言，耦合度相对较低，成员对象的变化对新对象的影响不大；合成复用可以在运行时动态进行，新对象可以引用与成员对象类型相同的其他对象。

#### 迪米特原则
一个软件实体应当尽可能少地与其他实体发生相互作用。考虑通过引入一个合理的第三者来降低现有对象直接的耦合度，例如EventBus作为数据中转。

在类的划分上，应当尽量创建松耦合的类，类的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的设计结构上，每一个类都应当尽量降低成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。
