&emsp;&emsp;要注意`Java`的`import`并没有真的把该文件导入，只是用于避免每次用到一个类都要写全包名，和`C/C++`的`include`是不一样的。`C/C++`是会把头文件复制进来，最后合成一个可执行文件，也就是除了动态链接库，都会合成一个文件。而`Java`是把每个文件分别编译成字节码文件，执行时才由虚拟机加载，相当于每个`class`文件都是动态链接来执行。
## 1.类路径
要是类文件被多个程序共享，需要做到下面几点：
1. 如果是`.class`文件，将它放到一个目录中，包名需要和目录对应
2. 如果是**JAR**包，放到一个目录中
3. 设置类路径（class path），必须包含要用到的所有类文件的路径

> 由于运行时库文件（`rt.jar`和在`jre/lib`与`jre/lib/ext`目录下的一些**JAR**文件）会被自动地搜索，所以可以不用把它们显式地列在类路径中

> **注意：**`javac`编译器总会在当前目录查找文件，但Java虚拟机仅在类路径中有“.”目录时才查看当前目录。如果没有设置类路径可能会导致通过编译但是不能运行。

### 1.1 虚拟机查找类文件
1. 先查找存储在jre/lib和jre/lib/ext目录中的系统类文件
2. 找不到就到类路径中列出的路径去查找

### 1.2 编译器查找类文件
1. 先在类路径中查找import的所有包名对应的目录（java.lang包被默认导入）
2. 没有就从当前目录中对应包名路径查找

javac命令编译Java源文件时，如果Main依赖A，那么编译Main必须有A的源文件或者类文件才能通过编译，而编译A则只需要A，因为A没有依赖其他类。  
而C语言，编译成拓展名为.o的目标文件是不用依赖的C文件的，但是编译为可执行文件时是需要的。

## 2.类加载器
每个Java程序至少拥有三个类加载器：
* 引导类加载器（`Bootstrap`）：`rt.jar`
* 扩展类加载器（`Extension`）：`jre/lib/ext`
* 系统类加载器（`System`）：`CLASSPATH`

还可以自定义类加载器

双亲委派模型：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

通过这种层级关可以避免类的重复加载，其次是考虑到安全因素，java核心api中定义类型不会被随意替换