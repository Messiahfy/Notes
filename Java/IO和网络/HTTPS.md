### HTTPS概述
* HTTP 是明文传输，HTTPS 通过 SSL/TLS （TCP/IP和HTTP之间）进行了加密；
* HTTP 的端口号是 80，HTTPS 是 443
* HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费
* HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL/TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

![数字证书](https://upload-images.jianshu.io/upload_images/3468445-f45803cb14161fb0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

SSL/TLS主要完成：
1. 认证客户端和服务器（验证证书）
2. 加密数据（加密）
3. 保证数据完整性（摘要算法）

### 加密方式 
`对称加密`：双方用相同的密钥加密解密，可以保证通信安全。但是存在双方如何都拥有密钥的问题，如果服务器传输给客户端，过程中密钥就可能被劫持。

`非对称`：公钥密钥成对存在，客户端使用公钥加密，服务器使用私钥解密。客户端使用公钥加密后发给服务器，即使被截获也无法解密

但是一是非对称加密耗时，二是存在中间人劫持的问题。中间人可以先把拦截客户端请求公钥A，让服务器把公钥A发给自己，再把假公钥A发给客户端，客户端用假公钥A加密信息，中间人可以用假私钥A解密得到信息。

非对称加密+对称加密：服务器把公钥A发给客户端，客户端用公钥加密对称秘钥发回服务器，服务器用私钥解密得到对称秘钥，后面就用对称秘钥传递数据，也就是用非对称加密对称秘钥。

此时发现 非对称加密+对称加密 同样存在中间人劫持的问题

**https关键**：先把公钥发给客户端，客户端用公钥加密对称秘钥发回服务器，服务器用私钥解密得到对称秘钥，后面就用对称秘钥传递数据，也就是用非对称加密对称秘钥，但如何确保公钥就是服务器发来的，就要用到**证书**。

* 先使用非对称加密：服务器先用CA私钥把公钥（非CA公钥，而是与客户端用来加密对称秘钥的公钥）经过hash算法后的消息摘要加密成数字签名，然后把公钥等信息和数字签名合并为数字证书发给客户端（公钥就包含在数字证书中），客户端用CA（Certificate Authority，证书颁发机构）的公钥解密数字签名，得到的消息摘要和对公钥+个人信息的hash结果对比相同，则认为公钥没有被篡改，是服务器发来的。
* 然后就用服务器发来的公钥加密对称秘钥，服务器收到密文就用私钥解密得到对称秘钥，后续则用此对称秘钥来加密和解密数据（因为对称加密速度更快）。
* 而CA的公钥私钥则是事先就已经存在于客户端和服务器。现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。
* 一般访问https网站不需要处理，因为权威CA颁发的证书可信任，但如果是自签名证书，就需要自行配置了。
![验证是否被篡改](https://upload-images.jianshu.io/upload_images/3468445-0d0e02c7c1b32191.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


[谈谈HTTPS](https://juejin.im/post/59e4c02151882578d02f4aca)

### HTTPS流程
一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了。
5. 客户端将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。


### Java中使用SSL/TLS
HTTPS协议实质就是SSL/TLS+HTTP，HTTP协议会使用Socket完成网络通信，而HTTPS则要使用SSLSocket来完成网络通信。SSLSocket包含了普通Socket的功能，并且添加了SSL/TLS协议来完成安全保证。所以无需关心SSL/TLS的具体工作流程，使用SSLSocket即可。

1. 通过SSLContext的静态方法getInstance获取实例
2. 使用SSLContext的init方法初始化，可以配置密钥和信任管理器
3. 通过SSLContext的getSocketFactory()得到SSLSocketFactory实例
4. 通过SSLSocketFactory实例的createSocket方法就可以得到SSLSocket实例
5. 然后像使用Socket那样使用SSLSocket读写流即可

KeyManager和TrustManager在Java中完成不同的目的，TrustManager确定是否应该信任远程连接，通过**验证证书**，确认服务器是否是我们想要连接的服务器，也就是说一般用于客户端使用；而KeyManager确定应在SSL/TLS握手期间将哪些身份验证凭据发送到远程主机以进行身份​​验证，负责提供证书和私钥，证书会发给客户端，也就说一般用于服务器使用；如果需要双向认证，那么我们的客户端也需要使用KeyManager，客户端和服务器是相对的。

### 客户端配置自签名证书
如果不使用CA机构颁发的证书，而使用自签名证书，则要么直接信任所有证书，要么自行设置信任特定证书。当前，信任所有证书不安全，一般要自行设置特定证书。

[Android Https相关完全解析 当OkHttp遇到Https](https://blog.csdn.net/lmj623565791/article/details/48129405)
还有其他写法，但本质一样
关键都是给OkHttpClient设置SslSocketFactory，而SslSocketFactory需要配置TrustManager