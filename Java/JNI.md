## 1.概述从Java程序中调用C函数
1. 首先在Java代码中声明native方法，关键字native提醒编译器该方法将在外部定义
```
public class HelloNative {
    public static native void greeting();// 本地方法可以是静态也可以是非静态的
}
```

2. 编译此java文件为class文件
```
javac HelloNative.java
```

3. 使用 javah 处理 HelloNative.class 文件，生成 HelloNative.h 头文件
```
javah HelloNative

// HelloNative.h 内容

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloNative */

#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloNative
 * Method:    greeting
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_greeting
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```
宏 JNIEXPORT 和 JNICALL 是在头文件 <jni.h> 中定义的， JNIEXPORT 和 JNICALL 都是只定义了宏名，无其他具体作用，用于编译器识别。

4. 实现 native 函数

    函数名称就是生成的 HelloNative.h 头文件中的函数声明，名称为 Java_ 加上完整包名和方法名，并把点号换为下划线。比如 Java_HelloNative_greeting ,如果属于某个包，则例如 Java_com_hfy_HelloNative_greeting 。

    但是这些规则并不需要记忆，因为第3步使用 javah 命令生成的头文件中已经生成好函数名。

    将函数原型从头文件中复制到源文件 HelloNative.c 中，并且实现该函数
```
#include "HelloNative.h"
#include <stdio.h>
JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv * env, jclass cl){
    printf("Hello Native World!\n");
}
```

5. 编译动态链接库
```
gcc -fPIC -I /Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/include  -shared HelloNative.c -o libHelloNative.so
```
mac编译，会提示错误 'jni_md.h' file not found，此头文件在 jdk/Contents/Home/include/darwin 中，复制或者添加路径到gcc命令中即可。

6. 执行
```
public class Main {
    public static void main(String[] args) {
        System.out.println(System.getProperty("java.library.path"));//可查看jni搜索动态链接库的路径
        HelloNative.greeting();
    }

    static {
        System.load("/Users/huangfeiyang/Desktop/libHelloNative.so");//加载动态库
        // System.loadLibrary("HelloNative");  mac上使用此方式有问题，可能与mac上使用dylib有关，暂不深究
    }
}
```

注意包名要对应上，用于 javah 编译的类的包名与 native 实现的函数名要对应

## 2. 数值参数与返回值
&emsp;&emsp;当在C与Java之间传递数字时，应该知道它们彼此之间的对应类型。例如，C中也有int和long类型，但是它们的实现取决于平台，有些平台上，int是16位的，有些是32位的。但是Java平台上int类型总是32位的整数。基于这个原因，Java本地接口（JNI）定义了jint、jlong等类型。

| Java语言 | C语言 | 字节 |
|---|---|---|
| boolean | jboolean | 1 |
| byte | jbyte | 1 |
| char | jchar | 2 |
| short | jshort | 2 |
| int | jint | 4 |
| long | jlong | 8 |
| float | jfloat | 4 |
| double | jdouble | 8 |

&emsp;&emsp;在头文件 jni.h 中，这些类型被 typedef 语句声明为在目标平台上等价的类型。该头文件中还定义常量 JNI_FALSE = 0 和 JNI_TRUE = 1

&emsp;&emsp; jni.h 中也包含了 jni_md.h，例如jint位于 jni_md.h，声明为 typedef int jint;

在C语言中，实现函数时，参数和变量的声明都使用 jint 等。

例如 Java 中：
```
//省略其他代码
public static native int fun(int i);
```

则在C语言中：
```
//省略头文件等
JNIEXPORT jint JNICALL Java_HelloNative_fun(JNIEnv * env, jclass cl, jint i){
    //...
}
```

## 3. 字符串参数
&emsp;&emsp;Java中的字符串是UTF-16编码点的序列，而C的字符串则是以null结尾的字符序列，所以在这两种语言中的字符串的差别很大。JNI有两组操作字符串的函数，一组把Java字符串转换成“改良的UTF-8”字节序列，另一组将它们转换为UTF-16数值的数组，也就是转换成jint数组。
&emsp;&emsp;带有字符串参数或返回值的native方法都要接受一个 jstring 类型的值或返回一个 jstring 类型的值。JNI函数将读入并构造这些 jstring 对象。例如：
```
JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv * env, jclass cl){
    jstring jstr;
    char greeting[] = "Hello Native World\n"
    jstr = (*env)->NewStringUTF(env, greeting);
    return jstr;
}
```

## 4. 访问域
native方法的第一个参数是JNIEnv指针，JNIEnv 是一个JNI接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数来访问JVM中的方法、数据结构。

native方法的第二个参数是 jclass 或者 jobject。当所声明Native方法是静态方法时，对应参数jclass，因为静态方法不依赖对象实例，而依赖于类，如果声明的Native方法时非静态方法时，那么对应参数是jobject。

```
//Java native方法
public native void raiseSalary(double byPercent);

//对应到C语言
JNIEXPORT void JNICALL Java_Employee_raiseSalary(JNIEnv * env, jobject this_obj, jdouble byPercent){
    //获取类
    jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
    //获取字段ID，D为编码签名，在下一节探讨
    jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D);
    //获取字段值
    jdouble salary = (*env)->GetDoubleField(env, this_obj, id_salary);
    salary *= 1 + byPercent / 100;
    //设置字段值
    (*env)->SetDoubleField(env, this_obj, id_salary, salary);
}
```

## 5. 编码签名
为了在C中访问实例字段和调用Java定义的方法，需要了解将数据结构的名称和方法签名进行“混编”的规则。
| 编码 | 类型 |
|---|---|
| B | byte |
| C | char |
| D | double |
| F | float |
| I | int |
| LclassName; | 类的类型 |
| S | short |
| V | void |
| Z | boolean |

描述数组，要使用[，例如，字符串数组：
```
[Ljava/lang/String;
```
float[][]如下：
```
[[F
```

一个方法的完整签名，需要参数和返回值。

一个接收两个整型并返回一个整型的方法编码为：
```
(II)I
```

接收一个字符串和double，并返回字符串的方法编码为：
```
(Ljava/lang/String;D)Ljava/lang/String;
```
类的类型的 L表达式结尾的分号是表达式的终止符，不是分隔符

## 6. 调用Java方法
1. 调用实例方法示例步骤
```
//获取类
jclass Class_PrintWriter = (*env)->GetObjectClass(env, out);
//获取方法ID
jmethodID id_print = (*env)GetMethodID(env, class_PrintWriter, "print", "(Ljava/lang/String;)V");
//调用方法
(*env)->CallVoidMethod(env, out, id_print, str);
```

2. 调用静态方法使用 GetStaticMethodID 和 CallStaticXxxMethod

3. 构造器 jobject obj_new = (*env)->NewObject(env, class, methodID, 构造参数)

## 7. 访问数组元素
Java的所有数组类型都有对应的C语言类型
| Java | C |
|---|---|
| boolean[] | jbooleanArray |
| byte[] | jbyteArray |
| char[] | jcharArray |
| int[] | jintArray |
| short[] | jshortArray |
| long[] | jlongArray |
| float[] | jfloatArray |
| double[] | jfloatArray |
| Object[] | jobjectArray |

在C中，这些数组类型实际上都是 jobject 的同义类型

## 8. 错误处理
使用本地方法存在很大风险，因为C的运行期系统对数组越界、不良指针造成的间接错误等不提供任何保护，所以处理所有的出错条件以保持Java平台的完整性很重要。尤其是当本地方法诊断出一个无法解决的问题时，应该将此问题报告给Java虚拟机。

```
//获取异常类
jclass class_EOFException = (*env)->FindClass(env, "java/io/EOFException");
//获取无参构造方法ID
jmethodID id_EOFException = (*env)->GetMethodID(env, class_EOFException, "<init>", "()V");
//构造异常对象
jthrowable obj_exc = (*env)->NewObject(env, class_EOFException, id_EOFException);
//抛出异常
(*env)->Throw(env, obj_exc);
```

通常调用ThrowNew会更加方便
```
(*env)->ThrowNew(env, (*env)->FindClass(env, "java/io/EOFException"), "Unexpected end of file");
```

Throw和ThrowNew都仅仅是发布异常，它们不会中断本地方法的执行流，而是本地方法返回时Java虚拟机才会抛出异常，所以一般要搭配return语句。

检查调用java方法后是否有异常抛出，如果没有异常，则返回NULL，否则返回当前异常对象的引用
```
jthrowable obj_exc = (*env)->ExceptionOccurred(env);
```
如果只需要检查是否有异常抛出，而不需要获得引用，可以使用：
```
jboolean occurred = (*env)->ExcptionCheck(env);
```
通常，有异常出现时，本地方法应该直接返回。那样，虚拟机就会将该异常传送给Java代码。但是，本地代码也可以分析异常对象，自行处理。如果自行处理，则使用如下函数来关闭该异常
```
(*env)->ExcptionClear(env);
```

## 9. 使用调用API（invocation API）
如果要在C/C++程序中调用Java代码，invocation API可以把Java虚拟机嵌入到C/C++中。下面是你初始化虚拟机所需的基本代码：
```
JavaVMOption options[1];
JavaVMInitArgs vm_args;
JavaVM *jvm;
JNIEnv *env;

options[0].optionString = "-Djava.class.path=.";

memset(&vm_args, 0, sizeof(vm_args));
vm_args.version = JNI_VERSION_1_2;
vm_args.nOptions = 1;
vm_args.options = nOptions;

JNI_CreateJavaVM(&jvm, (void**) &env, &vm_args);
```
调用JNI_CreateJavaVM将创建虚拟机，并且使指针jvm指向虚拟机，使指针env指向执行环境。

一旦设置完虚拟机，就可以通过env指针来调用Java方法。而要使用invocation API中的其他函数，就需要jvm指针。目前，只有四个这样的函数，最重要的一个是终止虚拟机的函数：
```
(*jvm)->DestroyJavaVM(jvm);
```

## 10. 线程的关系
Java调用jni时，Java和C/C++处于同一线程

使用JNI的情况下，在C中调用pthread_create创建线程，JVM并不知道它，可以使用AttachCurrentThread将该线程和JVM关联起来，从而得到当前线程的 JNIEnv 指针

## 11. 内存管理
https://www.jianshu.com/p/787053d11dfd

Local Reference、Global Reference、Weak Global Reference