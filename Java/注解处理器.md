运行时注解使用反射，比较简单，这里分析编译时注解的使用。

在每一轮中，处理器被要求处理在前一轮产生的源文件和类文件上找到的注解的子集。第一轮处理的输入是工具运行的初始输入;这些初始输入可以被视为虚拟第0轮处理的输出。如果要求处理器在给定轮次上进行处理，则会要求处理后续轮次，包括最后一轮，即使没有要处理的注解。工具基础结构还可以要求处理器处理由工具的操作隐式生成的文件。

这也就是说我们实现的process方法有可能会被调用多次，因为我们生成的文件也有可能会包含相应的注解。例如，我们的源文件为SourceActivity.class，生成的文件为Generated.class，这样就会有三次循环，第一次输入为SourceActivity.class，输出为Generated.class；第二次输入为Generated.class，输出并没有产生新文件；第三次输入为空，输出为空。

每次循环都会调用process方法，process方法提供了两个参数，第一个是我们请求处理注解类型的集合（也就是我们通过重写getSupportedAnnotationTypes方法所指定的注解类型），第二个是有关当前和上一次 循环的信息的环境。

每个处理器的实现必须提供公共无参构造函数来让工具使用以实例化处理器。工具基础结构将与实现此接口的类交互，如下所示：
* 调用无参构造函数
* 调用init
* 调用getSupportedAnnotationTypes、getSupportedOptions、getSupportedSourceVersion，这些方法每次运行仅调用一次，而不是每轮都调用
* 适当时，该工具调用Processor对象上的process方法;不会为每轮创建一个新的{@code Processor}对象